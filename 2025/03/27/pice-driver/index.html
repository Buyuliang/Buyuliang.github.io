<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PCIe-DRIVER | Hexo</title><meta name="author" content="Tom"><meta name="copyright" content="Tom"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="dma_alloc_noncoherentdma_alloc_noncoherent() 是 Linux 内核中的一个函数，用于分配非一致性内存（Non-Coherent Memory）用于 DMA（Direct Memory Access）操作。DMA 是一种数据传输技术，它允许外设直接访问系统内存，而无需通过 CPU 的中介。在进行 DMA 操作时，需要为外设分配一块物理内存区域，这个内存区域">
<meta property="og:type" content="article">
<meta property="og:title" content="PCIe-DRIVER">
<meta property="og:url" content="http://example.com/2025/03/27/pice-driver/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="dma_alloc_noncoherentdma_alloc_noncoherent() 是 Linux 内核中的一个函数，用于分配非一致性内存（Non-Coherent Memory）用于 DMA（Direct Memory Access）操作。DMA 是一种数据传输技术，它允许外设直接访问系统内存，而无需通过 CPU 的中介。在进行 DMA 操作时，需要为外设分配一块物理内存区域，这个内存区域">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2025-03-27T16:21:55.088Z">
<meta property="article:modified_time" content="2025-03-27T16:21:55.088Z">
<meta property="article:author" content="Tom">
<meta property="article:tag" content="PCIe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/03/27/pice-driver/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PCIe-DRIVER',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-27 16:21:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">14</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PCIe-DRIVER</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-27T16:21:55.088Z" title="Created 2025-03-27 16:21:55">2025-03-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-27T16:21:55.088Z" title="Updated 2025-03-27 16:21:55">2025-03-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PCIe/">PCIe</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PCIe-DRIVER"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="dma-alloc-noncoherent"><a href="#dma-alloc-noncoherent" class="headerlink" title="dma_alloc_noncoherent"></a>dma_alloc_noncoherent</h3><p>dma_alloc_noncoherent() 是 Linux 内核中的一个函数，用于分配非一致性内存（Non-Coherent Memory）用于 DMA（Direct Memory Access）操作。<br>DMA 是一种数据传输技术，它允许外设直接访问系统内存，而无需通过 CPU 的中介。在进行 DMA 操作时，需要为外设分配一块物理内存区域，这个内存区域通常需要是非一致性内存，以便与外设的特定要求兼容。<br>dma_alloc_noncoherent() 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dma_alloc_noncoherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">dma_addr_t</span> *dma_handle, <span class="type">gfp_t</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>它接受四个参数：</p>
<ul>
<li>dev：要分配 DMA 内存的设备。</li>
<li>size：要分配的内存大小。</li>
<li>dma_handle：用于接收分配的 DMA 内存的物理地址。</li>
<li>flags：内存分配的标志。</li>
</ul>
<p>使用 dma_alloc_noncoherent() 函数，可以为设备分配一块非一致性内存，并得到该内存的物理地址。<br>以下是一个示例，展示了如何使用 dma_alloc_noncoherent() 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/dma-mapping.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example_function</span><span class="params">(<span class="keyword">struct</span> device *dev)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">4096</span>;  <span class="comment">// 分配 4KB 的内存</span></span><br><span class="line">    <span class="type">dma_addr_t</span> dma_handle;</span><br><span class="line">    <span class="type">void</span> *dma_memory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配非一致性内存</span></span><br><span class="line">    dma_memory = dma_alloc_noncoherent(dev, size, &amp;dma_handle, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dma_memory) &#123;</span><br><span class="line">        <span class="comment">// 内存分配失败的处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用分配的 DMA 内存</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放分配的 DMA 内存</span></span><br><span class="line">    dma_free_noncoherent(dev, size, dma_memory, dma_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 dma_alloc_noncoherent() 函数分配了一块 4KB 的非一致性内存，并得到了该内存的物理地址 dma_handle。然后，我们可以使用这块分配的 DMA 内存进行相应的操作。最后，使用 dma_free_noncoherent() 函数释放分配的 DMA 内存。<br>需要注意的是，分配的 DMA 内存必须使用相应的释放函数进行释放，以避免内存泄漏。在实际使用中，还需要根据具体的需求和场景，进行其他必要的设置和配置，以确保 DMA 操作的正确性和性能。</p>
<h3 id="dma-alloc-coherent"><a href="#dma-alloc-coherent" class="headerlink" title="dma_alloc_coherent"></a>dma_alloc_coherent</h3><p><code>dma_alloc_coherent</code> 是 Linux 内核中的一个函数，用于分配一块连续的物理内存，并返回一个与设备 DMA（Direct Memory Access）引擎兼容的虚拟地址。</p>
<p>在 Linux 内核中，DMA 是一种直接内存访问技术，允许外设（如网络适配器、硬盘控制器等）直接读写系统内存，而不需要 CPU 的干预。为了在 DMA 操作中保证数据的正确性和一致性，需要使用与设备 DMA 引擎兼容的物理内存和虚拟地址。</p>
<p><code>dma_alloc_coherent</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">dma_addr_t</span> *dma_handle, <span class="type">gfp_t</span> flag)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受四个参数：</p>
<ul>
<li><code>dev</code>：指向设备结构的指针，表示要为该设备分配内存。</li>
<li><code>size</code>：要分配的内存大小，以字节为单位。</li>
<li><code>dma_handle</code>：指向 <code>dma_addr_t</code> 类型的指针，用于返回分配的物理内存的 DMA 地址。</li>
<li><code>flag</code>：内存分配标志，用于指定内存分配的行为，例如 GFP_KERNEL、GFP_ATOMIC 等。</li>
</ul>
<p><code>dma_alloc_coherent</code> 函数会分配一块物理内存，并返回一个与设备 DMA 引擎兼容的虚拟地址。同时，它会将分配的物理内存的 DMA 地址存储到 <code>dma_handle</code> 参数中，以便在 DMA 操作中使用。</p>
<p>以下是一个示例，展示了如何在 Linux 内核中使用 <code>dma_alloc_coherent</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/dma-mapping.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">example_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">4096</span>;  <span class="comment">// 分配 4KB 的内存</span></span><br><span class="line">    <span class="type">dma_addr_t</span> dma_handle;</span><br><span class="line">    <span class="type">void</span> *virt_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配连续的物理内存</span></span><br><span class="line">    virt_addr = dma_alloc_coherent(dev, size, &amp;dma_handle, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!virt_addr) &#123;</span><br><span class="line">        <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用虚拟地址和 DMA 地址进行 DMA 操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放分配的内存</span></span><br><span class="line">    dma_free_coherent(dev, size, virt_addr, dma_handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先使用 <code>dma_alloc_coherent</code> 函数分配一块连续的物理内存，大小为 4KB。然后，我们可以使用返回的虚拟地址和 DMA 地址进行 DMA 操作。最后，我们使用 <code>dma_free_coherent</code> 函数释放分配的内存。</p>
<p>需要注意的是，<code>dma_alloc_coherent</code> 和 <code>dma_free_coherent</code> 函数是成对使用的。在使用完分配的内存后，应该调用 <code>dma_free_coherent</code> 函数释放内存，以避免内存泄漏。</p>
<h3 id="非一致性内存和连续内存"><a href="#非一致性内存和连续内存" class="headerlink" title="非一致性内存和连续内存"></a>非一致性内存和连续内存</h3><p>非一致性内存 (Non-Uniform Memory Access, NUMA) 和连续内存 (Contiguous Memory) 是两个不同的概念，涉及到内存访问的方式和内存分配的特性。</p>
<ol>
<li><p>非一致性内存 (NUMA)：</p>
<ul>
<li>NUMA 是一种内存体系结构，其中系统中的不同处理器核心或节点可以访问本地内存或远程节点上的内存。</li>
<li>在 NUMA 架构中，每个处理器核心附近都有一块本地内存，访问本地内存的速度更快，而访问远程节点上的内存速度较慢。</li>
<li>这种内存访问模型适用于多处理器系统，可以提高内存访问的效率和可伸缩性。</li>
<li>在 NUMA 架构中，内存分配时需要考虑将数据分配到本地内存中，以减少远程内存访问的开销。</li>
</ul>
</li>
<li><p>连续内存 (Contiguous Memory)：</p>
<ul>
<li>连续内存是指在物理内存中连续的一段地址空间，没有间隙或断裂。</li>
<li>连续内存对于某些硬件设备和操作系统的要求非常重要，例如某些设备可能要求缓冲区必须是连续的，或者某些算法可能对连续内存的访问效率更高。</li>
<li>在内存分配时，操作系统会尽量分配连续的内存，以满足特定需求。</li>
</ul>
</li>
</ol>
<p>综上所述，非一致性内存和连续内存是两个不同的概念。非一致性内存是一种内存体系结构，涉及到处理器核心或节点之间的内存访问模式。而连续内存是指物理内存中连续的地址空间，用于满足特定设备或算法对连续内存的要求。</p>
<h3 id="build-skb-for-dma"><a href="#build-skb-for-dma" class="headerlink" title="build_skb_for_dma"></a>build_skb_for_dma</h3><p>build_skb_for_dma() 是一个虚拟函数，用于在 Linux 内核中为 DMA（Direct Memory Access）操作构建一个用于传输的 skb（socket buffer）。<br>在 Linux 内核中，skb 是一个数据结构，用于在网络协议栈中传输数据。DMA 是一种数据传输技术，它允许外设直接访问系统内存，而无需通过 CPU 的中介。当需要将数据从内存传输到外设或从外设传输到内存时，可以使用 skb 来管理数据的缓冲区。<br>build_skb_for_dma() 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">build_skb_for_dma</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *data, <span class="type">unsigned</span> <span class="type">int</span> len, <span class="type">gfp_t</span> gfp)</span>;</span><br></pre></td></tr></table></figure>
<p>它接受四个参数：</p>
<ul>
<li>dev：进行 DMA 操作的设备。</li>
<li>data：指向数据的指针。</li>
<li>len：数据的长度。</li>
<li>gfp：内存分配的标志。</li>
</ul>
<p>使用 build_skb_for_dma() 函数，可以为 DMA 操作构建一个 skb，以便在数据传输过程中管理数据的缓冲区。<br>以下是一个示例，展示了如何使用 build_skb_for_dma() 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example_function</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *data, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建用于 DMA 的 skb</span></span><br><span class="line">    skb = build_skb_for_dma(dev, data, len, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">        <span class="comment">// 构建 skb 失败的处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用构建的 skb 进行 DMA 操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 skb</span></span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 build_skb_for_dma() 函数为 DMA 操作构建了一个 skb，并使用 data 和 len 参数指定了数据的指针和长度。然后，我们可以使用这个构建的 skb 来进行相应的 DMA 操作。最后，使用 kfree_skb() 函数释放构建的 skb。<br>需要注意的是，构建的 skb 必须使用相应的释放函数进行释放，以避免内存泄漏。在实际使用中，还需要根据具体的需求和场景，进行其他必要的设置和配置，以确保 DMA 操作的正确性和性能。</p>
<h3 id="kcalloc"><a href="#kcalloc" class="headerlink" title="kcalloc"></a>kcalloc</h3><p>kcalloc 是 Linux 内核中的一个函数，用于动态分配内存并将其初始化为零。它类似于标准库函数 calloc，但是专门为内核开发而设计。<br>kcalloc 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kcalloc</span><span class="params">(<span class="type">size_t</span> n, <span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>它接受三个参数：</p>
<ul>
<li>n：要分配的元素数量。</li>
<li>size：每个元素的大小（以字节为单位）。</li>
<li>flags：内存分配的标志，用于指定内存分配的行为和特性。</li>
</ul>
<p>kcalloc 函数会根据给定的 n 和 size 计算出所需的总字节数，并在内核堆中分配相应大小的内存块。然后，它会将分配的内存块的所有字节都初始化为零。<br>这种零初始化的特性使得 kcalloc 在许多情况下很有用，例如在需要确保内存内容清零的安全性或初始化数据结构时。<br>需要注意的是，kcalloc 函数只能在内核上下文中使用，而不能在用户空间应用程序中调用。<br>以下是一个示例，展示了如何使用 kcalloc 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内核模块中使用 kcalloc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">example_function</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配并初始化包含 10 个 int 元素的数组</span></span><br><span class="line">    <span class="built_in">array</span> = kcalloc(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">array</span>) &#123;</span><br><span class="line">        <span class="comment">// 内存分配失败的处理逻辑</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 array 数组进行操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    kfree(<span class="built_in">array</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 kcalloc 分配了一个包含 10 个 int 元素的数组，并将其初始化为零。然后，我们可以使用该数组进行后续操作，并在不再需要时使用 kfree 函数释放内存。</p>
<h3 id="kzalloc"><a href="#kzalloc" class="headerlink" title="kzalloc"></a>kzalloc</h3><p>kzalloc 是 Linux 内核提供的一个函数，用于在内核中动态分配内存并将其初始化为零。<br>kzalloc 的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kzalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>它接受两个参数：</p>
<ul>
<li>size：要分配的内存大小（以字节为单位）。</li>
<li>flags：内存分配的标志。</li>
</ul>
<p>kzalloc 函数类似于 kmalloc，但它会将分配的内存区域中的所有字节初始化为零。这对于需要初始化内存的情况非常有用，以避免使用未初始化的内存数据。<br>以下是一个示例，展示了如何在 Linux 内核中使用 kzalloc 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example_function</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配并初始化 10 个 int 类型的内存块</span></span><br><span class="line">    data = kzalloc(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="comment">// 内存分配失败的处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用分配的内存块</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    kfree(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 kzalloc 函数分配了一个大小为 10 个 int 类型的内存块，并将其初始化为零。然后，我们可以使用这个分配的内存块来存储数据或执行其他操作。最后，使用 kfree 函数释放分配的内存。<br>需要注意的是，使用 kzalloc 分配的内存必须使用相应的释放函数进行释放，以避免内存泄漏。在实际使用中，还需要根据具体的需求和场景，进行其他必要的内存管理和错误处理。</p>
<h3 id="kzalloc-kcalloc-区别"><a href="#kzalloc-kcalloc-区别" class="headerlink" title="kzalloc kcalloc 区别"></a>kzalloc kcalloc 区别</h3><p><code>kzalloc</code> 和 <code>kcalloc</code> 都是 Linux 内核中用于动态分配内存的函数，但它们在分配和初始化内存的方式上略有不同。</p>
<p><code>kzalloc</code> 函数用于分配一块大小为 <code>size</code> 字节的内存，并将其初始化为零。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kzalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p><code>kzalloc</code> 分配的内存块中的所有字节都被初始化为零。这对于需要使用已初始化内存的情况很有用，以避免使用未初始化的内存数据。</p>
<p><code>kcalloc</code> 函数用于分配一块大小为 <code>nmemb * size</code> 字节的内存，并将其初始化为零。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kcalloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p><code>kcalloc</code> 分配的内存块中的所有字节都被初始化为零，与 <code>kzalloc</code> 不同的是，它可以指定要分配的元素数量 <code>nmemb</code> 和每个元素的大小 <code>size</code>。</p>
<p>因此，<code>kzalloc</code> 和 <code>kcalloc</code> 的区别在于分配内存的方式。<code>kzalloc</code> 是根据指定的大小分配内存并初始化为零，而 <code>kcalloc</code> 则是根据指定的元素数量和元素大小分配内存并初始化为零。</p>
<h3 id="devm-ioremap-resource"><a href="#devm-ioremap-resource" class="headerlink" title="devm_ioremap_resource"></a>devm_ioremap_resource</h3><p><code>devm_ioremap_resource</code> 是 Linux 内核中的一个函数，用于将设备的 I&#x2F;O 资源映射到内核的虚拟地址空间中。<br>在 Linux 内核中，设备的 I&#x2F;O 资源通常是通过设备树（Device Tree）或 ACPI（Advanced Configuration and Power Interface）描述的。这些资源可能包括寄存器、控制寄存器、缓冲区等，用于与设备进行通信。</p>
<p><code>devm_ioremap_resource</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __iomem *<span class="title function_">devm_ioremap_resource</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> resource *res)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数：</p>
<ul>
<li><code>dev</code>：指向设备结构的指针。</li>
<li><code>res</code>：指向 I&#x2F;O 资源结构的指针。</li>
</ul>
<p><code>devm_ioremap_resource</code> 函数将 I&#x2F;O 资源映射到内核的虚拟地址空间，并返回映射后的虚拟地址。通过这个虚拟地址，可以直接访问设备的寄存器或缓冲区。</p>
<p>以下是一个示例，展示了如何在 Linux 内核中使用 <code>devm_ioremap_resource</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">example_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="type">void</span> __iomem *ioaddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设备的 I/O 资源</span></span><br><span class="line">    res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">        <span class="comment">// 处理获取资源失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射 I/O 资源到内核的虚拟地址空间</span></span><br><span class="line">    ioaddr = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(ioaddr)) &#123;</span><br><span class="line">        <span class="comment">// 处理映射失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(ioaddr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用映射后的虚拟地址访问设备</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先使用 <code>platform_get_resource</code> 函数获取设备的 I&#x2F;O 资源。然后，我们使用 <code>devm_ioremap_resource</code> 函数将该资源映射到内核的虚拟地址空间，并获得映射后的虚拟地址。最后，我们可以使用这个虚拟地址来访问设备的寄存器或缓冲区。</p>
<p>需要注意的是，<code>devm_ioremap_resource</code> 函数是通过使用 <code>ioremap</code> 和 <code>devm_add_action</code> 函数来进行资源管理的。这意味着在设备被释放时，内核会自动释放映射的内存。因此，不需要手动释放映射的内存。</p>
<p>在实际使用中，还需要根据具体的设备和驱动程序需求进行适当的错误处理和资源管理。</p>
<h3 id="Jhash"><a href="#Jhash" class="headerlink" title="Jhash"></a>Jhash</h3><p>JHash 是一个哈希函数，它是Linux内核中的一个散列函数，用于将输入数据映射为固定长度的哈希值。JHash 主要用于网络协议和数据包处理中，特别是用于散列 IP 地址和网络流量等信息。</p>
<p>JHash 的设计目标是快速计算和良好的分布特性。它采用了一系列位操作和数学运算，以生成均匀分布的哈希值。JHash 算法使用了乘法、位移和异或等操作，以及一些特定的常数和位掩码。</p>
<p>JHash 的算法实现是基于一种称为 “Jenkins One-at-a-Time” 的哈希函数。这种哈希函数的设计原则是简单高效，并且能够在一次迭代中处理每个输入字节。它通过使用累加器和混合步骤来处理输入数据，最后生成哈希值。</p>
<p>JHash 在 Linux 内核中广泛应用于散列表、路由表和其他网络相关的数据结构中。它被设计为快速计算和尽可能避免哈希冲突，以提高数据结构的性能和可靠性。</p>
<p>需要注意的是，JHash 是 Linux 内核中特定的哈希函数实现，具体的代码和细节可以在内核源代码中找到。在其他编程环境中可能有其他哈希函数的实现，所以如果你在其他环境中使用哈希函数，可能会使用不同的算法或名称。</p>
<h3 id="devm-request-irq"><a href="#devm-request-irq" class="headerlink" title="devm_request_irq"></a>devm_request_irq</h3><p><code>devm_request_irq</code> 是 Linux 内核中的一个函数，用于请求和注册中断处理程序。它是在设备驱动程序中使用的一种便捷方式，用于申请与特定设备相关的中断，并将中断处理程序与该设备关联起来。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">devm_request_irq</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">                     <span class="type">unsigned</span> <span class="type">long</span> irq_flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释如下：</p>
<ul>
<li><code>dev</code>：指向设备结构体的指针，表示与中断相关联的设备。</li>
<li><code>irq</code>：表示要请求的中断号。</li>
<li><code>handler</code>：指向中断处理程序的函数指针，用于处理中断事件。</li>
<li><code>irq_flags</code>：表示中断标志，如中断触发类型和中断共享属性等。</li>
<li><code>name</code>：表示中断处理程序的名称，用于标识中断处理程序。</li>
<li><code>dev_id</code>：用于传递与中断处理程序相关的设备特定数据。</li>
</ul>
<p><code>devm_request_irq</code> 函数的作用是在设备驱动程序中注册中断处理程序，并将中断与设备相关联。它还会处理内存管理和资源释放，使用了 <code>devm</code> 的内存管理机制，使得中断处理程序在设备被释放时会自动进行清理。</p>
<p>需要注意的是，使用 <code>devm_request_irq</code> 函数请求中断需要在设备的 probe 函数中进行，并且需要正确设置中断处理程序以及相应的中断处理机制，以确保中断能够正确地触发和处理。</p>
<h3 id="msecs-to-jiffies"><a href="#msecs-to-jiffies" class="headerlink" title="msecs_to_jiffies"></a>msecs_to_jiffies</h3><p><code>msecs_to_jiffies</code> 是 Linux 内核中的一个函数，用于将毫秒（milliseconds）转换为内核中的节拍数（jiffies）。在内核中，节拍数是一个用于度量时间的基本单元，它表示时钟中断发生的次数。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">msecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> m)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释如下：</p>
<ul>
<li><code>m</code>：表示要转换的毫秒数。</li>
</ul>
<p><code>msecs_to_jiffies</code> 函数的作用是将给定的毫秒数转换为内核中使用的节拍数。它使用系统的时钟频率和节拍间隔来进行转换。具体的转换算法可能因内核版本和配置而有所不同。</p>
<p>需要注意的是，节拍数是相对于特定的硬件和系统配置的，不同的系统可能具有不同的节拍间隔和时钟频率。因此，在使用 <code>msecs_to_jiffies</code> 进行转换时，应该考虑当前系统的配置和环境。</p>
<p>在内核编程中，<code>msecs_to_jiffies</code> 函数通常用于计算延迟时间或定时器的触发间隔。通过将时间转换为节拍数，可以确保定时器在正确的时机触发，并与内核的时钟同步。</p>
<p>如果你需要更多关于 <code>msecs_to_jiffies</code> 函数的信息，或者在特定的上下文中使用它，请提供更多细节，我将尽力提供帮助。</p>
<h3 id="dma-map-single"><a href="#dma-map-single" class="headerlink" title="dma_map_single"></a>dma_map_single</h3><p><code>dma_map_single()</code> 是 Linux 内核中的一个函数，用于将单个内存区域映射到可进行直接内存访问（Direct Memory Access，DMA）的设备。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dma_addr_t</span> <span class="title function_">dma_map_single</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *addr, <span class="type">size_t</span> size, <span class="keyword">enum</span> dma_data_direction dir)</span>;</span><br></pre></td></tr></table></figure>

<p>函数参数的含义如下：</p>
<ul>
<li><code>dev</code>：指向设备结构体的指针，表示要进行 DMA 操作的设备。</li>
<li><code>addr</code>：指向要映射的内存区域的起始地址。</li>
<li><code>size</code>：要映射的内存区域的大小，以字节为单位。</li>
<li><code>dir</code>：指定数据传输的方向，可以是 <code>DMA_TO_DEVICE</code>（从内存到设备）或 <code>DMA_FROM_DEVICE</code>（从设备到内存）。</li>
</ul>
<p><code>dma_map_single()</code> 函数将指定的内存区域进行物理地址映射，以便设备可以直接访问该内存区域，而不需要通过 CPU。函数返回一个 <code>dma_addr_t</code> 类型的值，表示映射后的物理地址。</p>
<p>需要注意的是，<code>dma_map_single()</code> 函数通常在设备驱动程序中使用，用于在进行 DMA 操作之前将内存区域映射到设备。对于不同的设备和架构，可能还需要进行其他的 DMA 相关设置，如设置 DMA 缓冲区、DMA 写入或读取操作等。</p>
<h3 id="dma-unmap-single"><a href="#dma-unmap-single" class="headerlink" title="dma_unmap_single"></a>dma_unmap_single</h3><p><code>dma_unmap_single</code> 是 Linux 内核中的一个函数，用于解除通过 DMA（Direct Memory Access，直接内存访问）映射的单个数据缓冲区。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dma_unmap_single</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">dma_addr_t</span> dma_addr, <span class="type">size_t</span> size, <span class="keyword">enum</span> dma_data_direction direction)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释如下：</p>
<ul>
<li><code>dev</code>：指向 <code>struct device</code> 结构体的指针，表示设备的指针，用于与 DMA 控制器进行通信。</li>
<li><code>dma_addr</code>：表示通过 DMA 映射的物理内存地址。</li>
<li><code>size</code>：表示映射的数据缓冲区的大小。</li>
<li><code>direction</code>：表示数据传输的方向，可以是 <code>DMA_TO_DEVICE</code>（从内存到设备）或 <code>DMA_FROM_DEVICE</code>（从设备到内存）。</li>
</ul>
<p><code>dma_unmap_single</code> 函数的作用是解除通过 DMA 映射的单个数据缓冲区，以便在数据传输完成后释放相关资源。在进行 DMA 数据传输之前，通常需要使用 <code>dma_map_single</code> 函数将数据缓冲区映射到物理内存，并获取对应的 DMA 地址。而在数据传输完成后，使用 <code>dma_unmap_single</code> 函数解除这个映射。</p>
<p>该函数会通知 DMA 控制器解除对应的 DMA 映射，并释放相关的硬件资源。这样可以确保 DMA 操作的正确性和数据的一致性。</p>
<p>需要注意的是，<code>dma_unmap_single</code> 函数仅适用于通过 <code>dma_map_single</code> 函数进行单个数据缓冲区映射的情况。对于多个数据缓冲区的映射，可以使用相应的函数，如 <code>dma_unmap_page</code> 或 <code>dma_unmap_sg</code>。</p>
<h3 id="mb"><a href="#mb" class="headerlink" title="mb"></a>mb</h3><p>在 C 语言中，<code>mb()</code> 是一种内存屏障（memory barrier）指令，用于确保内存操作的顺序性和一致性。</p>
<p>内存屏障是一种编程指令，用于指示处理器或编译器在某个点上必须确保内存操作的可见性和顺序性。它可以用来避免编译器优化、处理器乱序执行等可能导致的内存操作重排问题。</p>
<p><code>mb()</code> 是一种全序内存屏障指令，在调用点之前和之后，确保所有的内存读写操作都按照程序的执行顺序进行，不会被重排到屏障之后执行。</p>
<p>内存屏障的使用可以在多线程或多处理器的环境中确保共享内存的一致性。它可以用于同步线程的操作，保证正确的内存可见性和数据同步。</p>
<p>需要注意的是，<code>mb()</code> 是一种较为底层的内存屏障指令，通常在编写并发或并行程序时使用。在一般的应用程序开发中，使用更高级的同步原语和线程库可能更加方便和安全。</p>
<h3 id="alloc-etherdev-mqs"><a href="#alloc-etherdev-mqs" class="headerlink" title="alloc_etherdev_mqs"></a>alloc_etherdev_mqs</h3><p><code>alloc_etherdev_mqs</code> 是一个函数，用于在 Linux 内核中为以太网设备分配和初始化内存。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> net_device *<span class="title function_">alloc_etherdev_mqs</span><span class="params">(<span class="type">int</span> sizeof_priv, <span class="type">unsigned</span> <span class="type">int</span> txqs, <span class="type">unsigned</span> <span class="type">int</span> rxqs)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释如下：</p>
<ul>
<li><code>sizeof_priv</code>：表示设备私有数据结构的大小。</li>
<li><code>txqs</code>：表示要为设备分配的传输队列数量。</li>
<li><code>rxqs</code>：表示要为设备分配的接收队列数量。</li>
</ul>
<p><code>alloc_etherdev_mqs</code> 函数的作用是为以太网设备分配并初始化必要的内存结构。它会为设备分配一个 <code>struct net_device</code> 结构体，并根据参数指定的大小和数量分配相应的内存空间。</p>
<p>此函数通常用于在内核中创建新的以太网设备。它会为设备分配必要的内存资源，并初始化设备的各种字段和数据结构。分配的内存包括以太网设备的私有数据结构、传输队列和接收队列等。</p>
<p>需要注意的是，<code>alloc_etherdev_mqs</code> 函数是一个较为底层的函数，通常在以太网设备驱动程序中使用。在一般的应用程序开发中，不直接使用该函数，而是通过更高级的网络编程接口来创建和管理网络设备。</p>
<h3 id="netdev-priv"><a href="#netdev-priv" class="headerlink" title="netdev_priv"></a>netdev_priv</h3><p><code>netdev_priv</code> 是一个宏（macro），用于获取与给定的网络设备关联的私有数据结构的指针。</p>
<p>在 Linux 内核中，每个网络设备（<code>struct net_device</code>）都有一个指向私有数据结构的指针。通常，设备驱动程序会在创建网络设备时分配并关联一个私有数据结构。这个私有数据结构存储了驱动程序需要维护的设备特定的信息。</p>
<p><code>netdev_priv</code> 宏的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">netdev_priv</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向 <code>struct net_device</code> 的指针，表示要获取私有数据的网络设备。</p>
<p>使用 <code>netdev_priv</code> 宏时，你需要将网络设备的指针作为参数传递给宏，并将返回的指针转换为适当的类型，以访问和操作私有数据。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_private_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> my_variable;</span><br><span class="line">    <span class="comment">// other fields specific to the driver</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_private_data</span> *<span class="title">priv_data</span>;</span></span><br><span class="line"></span><br><span class="line">priv_data = netdev_priv(my_dev);</span><br><span class="line">priv_data-&gt;my_variable = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个指向网络设备的指针，并且与之关联的私有数据结构是 <code>struct my_private_data</code>。通过使用 <code>netdev_priv</code> 宏，我们可以获取指向私有数据结构的指针，并对其进行操作。</p>
<p>需要注意的是，使用 <code>netdev_priv</code> 宏时需要小心，确保传递正确的网络设备指针，以及正确的私有数据结构类型。</p>
<p>如果你需要更多关于 <code>netdev_priv</code> 宏的信息，或者有其他相关问题，请提供更多细节，我将尽力提<code>netdev_priv</code> 是一个宏（macro），用于获取与给定的网络设备关联的私有数据结构的指针。</p>
<p>在 Linux 内核中，每个网络设备（<code>struct net_device</code>）都有一个指向私有数据结构的指针。通常，设备驱动程序会在创建网络设备时分配并关联一个私有数据结构。这个私有数据结构存储了驱动程序需要维护的设备特定的信息。</p>
<p><code>netdev_priv</code> 宏的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">netdev_priv</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向 <code>struct net_device</code> 的指针，表示要获取私有数据的网络设备。</p>
<p>使用 <code>netdev_priv</code> 宏时，你需要将网络设备的指针作为参数传递给宏，并将返回的指针转换为适当的类型，以访问和操作私有数据。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_private_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> my_variable;</span><br><span class="line">    <span class="comment">// other fields specific to the driver</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_private_data</span> *<span class="title">priv_data</span>;</span></span><br><span class="line"></span><br><span class="line">priv_data = netdev_priv(my_dev);</span><br><span class="line">priv_data-&gt;my_variable = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个指向网络设备的指针，并且与之关联的私有数据结构是 <code>struct my_private_data</code>。通过使用 <code>netdev_priv</code> 宏，我们可以获取指向私有数据结构的指针，并对其进行操作。</p>
<p>需要注意的是，使用 <code>netdev_priv</code> 宏时需要小心，确保传递正确的网络设备指针，以及正确的私有数据结构类型。</p>
<h3 id="SET-NETDEV-DEV"><a href="#SET-NETDEV-DEV" class="headerlink" title="SET_NETDEV_DEV"></a>SET_NETDEV_DEV</h3><p><code>SET_NETDEV_DEV</code> 是一个宏（macro），用于设置一个网络设备的关联设备。</p>
<p>在 Linux 内核中，一个网络设备（<code>struct net_device</code>）可以与一个设备对象（<code>struct device</code>）关联。这种关联通常在网络设备驱动程序中使用，用于与底层硬件或其他设备进行交互。</p>
<p><code>SET_NETDEV_DEV</code> 宏的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SET_NETDEV_DEV</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> device *new_dev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向 <code>struct net_device</code> 的指针，表示要设置关联设备的网络设备。而 <code>new_dev</code> 是一个指向 <code>struct device</code> 的指针，表示要与网络设备关联的设备对象。</p>
<p>使用 <code>SET_NETDEV_DEV</code> 宏时，你需要将网络设备指针和设备对象指针作为参数传递给宏。这将建立网络设备与设备对象之间的关联。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">my_device</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建设备对象 my_device</span></span><br><span class="line"></span><br><span class="line">SET_NETDEV_DEV(my_dev, my_device);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个指向网络设备的指针，<code>my_device</code> 是一个指向设备对象的指针。通过使用 <code>SET_NETDEV_DEV</code> 宏，我们将网络设备 <code>my_dev</code> 与设备对象 <code>my_device</code> 关联起来。</p>
<p>通过设置网络设备的关联设备，驱动程序可以利用设备对象的功能和属性，与底层硬件或其他设备进行交互。</p>
<p>需要注意的是，使用 <code>SET_NETDEV_DEV</code> 宏时需要小心，确保传递正确的网络设备指针和设备对象指针。</p>
<h3 id="netif-napi-add"><a href="#netif-napi-add" class="headerlink" title="netif_napi_add"></a>netif_napi_add</h3><p><code>netif_napi_add</code> 是一个函数，用于将 NAPI（New API）结构添加到网络设备以启用基于轮询的网络中断处理。</p>
<p>在 Linux 内核中，NAPI 提供了一种基于轮询的网络中断处理机制，用于提高网络性能。它允许网络设备驱动程序根据网络流量的负载情况来动态选择使用中断处理程序或轮询处理程序。</p>
<p><code>netif_napi_add</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_napi_add</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> napi_struct *napi, <span class="type">int</span> (*poll)(<span class="keyword">struct</span> napi_struct *, <span class="type">int</span>), <span class="type">int</span> weight)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向 <code>struct net_device</code> 的指针，表示要添加 NAPI 的网络设备。<code>napi</code> 是一个指向 <code>struct napi_struct</code> 的指针，表示要添加的 NAPI 结构。<code>poll</code> 是一个函数指针，表示轮询处理程序，用于处理接收到的网络数据包。<code>weight</code> 是一个整数，表示 NAPI 结构的权重，用于设置轮询处理程序的优先级。</p>
<p>使用 <code>netif_napi_add</code> 函数时，你需要传递正确的参数，以将 NAPI 结构添加到网络设备中。这将使网络设备驱动程序能够根据负载情况选择使用中断处理程序或轮询处理程序。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> <span class="title">my_napi</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev 和 my_napi</span></span><br><span class="line"></span><br><span class="line">netif_napi_add(my_dev, &amp;my_napi, my_poll_function, <span class="number">64</span>);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个指向网络设备的指针，<code>my_napi</code> 是一个 <code>struct napi_struct</code> 的实例，<code>my_poll_function</code> 是一个轮询处理程序。通过使用 <code>netif_napi_add</code> 函数，我们将 NAPI 结构 <code>my_napi</code> 添加到网络设备 <code>my_dev</code> 中，设置轮询处理程序为 <code>my_poll_function</code>，并将权重设置为 64。</p>
<p>通过添加 NAPI 结构，驱动程序可以利用基于轮询的网络中断处理机制，提高网络性能。</p>
<h3 id="SKB-DATA-ALIGN"><a href="#SKB-DATA-ALIGN" class="headerlink" title="SKB_DATA_ALIGN"></a>SKB_DATA_ALIGN</h3><p><code>SKB_DATA_ALIGN</code> 是一个宏（macro），用于对网络数据包（skb，即 struct sk_buff）中的数据进行对齐。</p>
<p>在 Linux 内核中，网络数据包（skb）是用于在网络协议栈中传输数据的数据结构。它包含了数据的实际内容，以及与数据包相关的元数据（如协议头、标志等）。</p>
<p><code>SKB_DATA_ALIGN</code> 宏的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SKB_DATA_ALIGN(skb) (((unsigned long)(skb)-&gt;data + NET_SKB_PAD) &amp; ~(NET_SKB_PAD - 1))</span></span><br></pre></td></tr></table></figure>

<p>宏 <code>SKB_DATA_ALIGN</code> 接受一个指向 <code>struct sk_buff</code> 的指针 <code>skb</code>，并返回对齐后的数据指针。</p>
<p>在内核中，网络数据包的数据通常需要按特定的对齐要求进行处理。<code>SKB_DATA_ALIGN</code> 宏通过将数据指针 <code>skb-&gt;data</code> 加上 <code>NET_SKB_PAD</code>（一个对齐常量），然后将结果与 <code>~(NET_SKB_PAD - 1)</code> 进行按位与操作，从而实现对齐。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *aligned_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 skb</span></span><br><span class="line"></span><br><span class="line">aligned_data = (<span class="type">unsigned</span> <span class="type">char</span> *)SKB_DATA_ALIGN(skb);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>skb</code> 是一个指向 <code>struct sk_buff</code> 的指针。通过使用 <code>SKB_DATA_ALIGN</code> 宏，我们将 <code>skb</code> 中的数据指针对齐，并将结果存储在 <code>aligned_data</code> 中。</p>
<p>对齐网络数据包的数据指针可能是为了满足硬件或协议的要求，以提高数据访问效率或兼容性。</p>
<h3 id="netif-set-real-num-tx-queues"><a href="#netif-set-real-num-tx-queues" class="headerlink" title="netif_set_real_num_tx_queues"></a>netif_set_real_num_tx_queues</h3><p><code>netif_set_real_num_tx_queues</code> 是一个函数，用于设置网络设备的实际传输队列数量。</p>
<p>在 Linux 内核中，网络设备可以具有多个传输队列，用于同时处理传输数据。这些传输队列可以提高网络性能，允许并行处理传输请求。</p>
<p><code>netif_set_real_num_tx_queues</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_set_real_num_tx_queues</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="type">unsigned</span> <span class="type">int</span> num_tx_queues)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向 <code>struct net_device</code> 的指针，表示要设置传输队列数量的网络设备。<code>num_tx_queues</code> 是一个无符号整数，表示要设置的传输队列数量。</p>
<p>使用 <code>netif_set_real_num_tx_queues</code> 函数时，你需要传递正确的参数，以设置网络设备的实际传输队列数量。这将影响网络设备在传输数据时的并行处理能力。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_queues = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev</span></span><br><span class="line"></span><br><span class="line">netif_set_real_num_tx_queues(my_dev, num_queues);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个指向网络设备的指针，<code>num_queues</code> 是一个表示传输队列数量的无符号整数。通过使用 <code>netif_set_real_num_tx_queues</code> 函数，我们设置网络设备 <code>my_dev</code> 的传输队列数量为 4。</p>
<p>通过设置实际传输队列数量，可以充分利用网络设备的并行处理能力，提高网络性能。</p>
<h3 id="netif-set-real-num-rx-queues"><a href="#netif-set-real-num-rx-queues" class="headerlink" title="netif_set_real_num_rx_queues"></a>netif_set_real_num_rx_queues</h3><p><code>netif_set_real_num_rx_queues</code> 是一个函数，用于设置网络设备的实际接收队列数量。</p>
<p>在 Linux 内核中，网络设备可以具有多个接收队列，用于同时接收数据包。这些接收队列可以提高网络性能，允许并行处理接收请求。</p>
<p><code>netif_set_real_num_rx_queues</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_set_real_num_rx_queues</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="type">unsigned</span> <span class="type">int</span> num_rx_queues)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向 <code>struct net_device</code> 的指针，表示要设置接收队列数量的网络设备。<code>num_rx_queues</code> 是一个无符号整数，表示要设置的接收队列数量。</p>
<p>使用 <code>netif_set_real_num_rx_queues</code> 函数时，你需要传递正确的参数，以设置网络设备的实际接收队列数量。这将影响网络设备在接收数据时的并行处理能力。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_queues = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev</span></span><br><span class="line"></span><br><span class="line">netif_set_real_num_rx_queues(my_dev, num_queues);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个指向网络设备的指针，<code>num_queues</code> 是一个表示接收队列数量的无符号整数。通过使用 <code>netif_set_real_num_rx_queues</code> 函数，我们设置网络设备 <code>my_dev</code> 的接收队列数量为 4。</p>
<p>通过设置实际接收队列数量，可以充分利用网络设备的并行处理能力，提高网络性能。</p>
<h3 id="register-netdev"><a href="#register-netdev" class="headerlink" title="register_netdev"></a>register_netdev</h3><p><code>register_netdev</code> 是一个函数，用于将一个网络设备注册到 Linux 内核网络子系统中。</p>
<p>在 Linux 内核中，网络设备由 <code>struct net_device</code> 结构体表示，通过将网络设备注册到内核中，可以使其能够参与网络数据的传输和处理。</p>
<p><code>register_netdev</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向 <code>struct net_device</code> 的指针，表示要注册的网络设备。</p>
<p>使用 <code>register_netdev</code> 函数时，你需要创建一个 <code>struct net_device</code> 结构体，并对其进行适当的初始化。然后，通过调用 <code>register_netdev</code> 函数，将该网络设备注册到内核网络子系统中。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = register_netdev(my_dev);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 注册失败的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个指向已经初始化的网络设备的指针。通过调用 <code>register_netdev</code> 函数，我们将该网络设备注册到内核网络子系统中。如果注册成功，<code>register_netdev</code> 函数将返回 0；否则，它将返回一个错误代码，你可以根据需要进行处理。</p>
<p>通过注册网络设备，可以使其能够参与网络数据的传输和处理，例如接收和发送数据包。</p>
<h3 id="unregister-netdev"><a href="#unregister-netdev" class="headerlink" title="unregister_netdev"></a>unregister_netdev</h3><p><code>unregister_netdev</code> 是一个函数，用于将一个已经注册的网络设备从 Linux 内核网络子系统中注销。</p>
<p>在 Linux 内核中，通过调用 <code>register_netdev</code> 函数将网络设备注册到内核网络子系统中。当不再需要该网络设备时，可以使用 <code>unregister_netdev</code> 函数将其从内核注销，以释放相关资源。</p>
<p><code>unregister_netdev</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unregister_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向已经注册的网络设备的指针，表示要注销的网络设备。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev</span></span><br><span class="line"></span><br><span class="line">unregister_netdev(my_dev);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个指向已经注册的网络设备的指针。通过调用 <code>unregister_netdev</code> 函数，我们将该网络设备从内核网络子系统中注销。</p>
<p>通过注销网络设备，可以释放相关资源，并确保不再使用该设备进行网络数据的传输和处理。</p>
<h3 id="netif-napi-del"><a href="#netif-napi-del" class="headerlink" title="netif_napi_del"></a>netif_napi_del</h3><p><code>netif_napi_del</code> 是一个函数，用于从网络设备中删除 NAPI 结构。</p>
<p>NAPI（New API）是 Linux 内核网络子系统中的一种机制，用于提高网络收发性能。它通过减少中断处理程序的执行次数来降低 CPU 使用率，并使用轮询方式处理网络数据包。</p>
<p><code>netif_napi_del</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_napi_del</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>napi</code> 是一个指向 <code>struct napi_struct</code> 的指针，表示要删除的 NAPI 结构。</p>
<p>使用 <code>netif_napi_del</code> 函数时，你需要传递正确的参数，以删除网络设备中的 NAPI 结构。这将释放与该 NAPI 结构相关的资源，并停止使用 NAPI 机制处理网络数据包。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> <span class="title">my_napi</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev 和 my_napi</span></span><br><span class="line"></span><br><span class="line">netif_napi_del(&amp;my_napi);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个指向网络设备的指针，<code>my_napi</code> 是一个已经初始化的 NAPI 结构。通过调用 <code>netif_napi_del</code> 函数，我们从网络设备 <code>my_dev</code> 中删除了 NAPI 结构 <code>my_napi</code>。</p>
<p>删除 NAPI 结构后，将恢复使用中断方式处理网络数据包。</p>
<h3 id="free-netdev"><a href="#free-netdev" class="headerlink" title="free_netdev"></a>free_netdev</h3><p><code>free_netdev</code> 是一个函数，用于释放一个网络设备所占用的资源并销毁该设备的数据结构。</p>
<p>在 Linux 内核中，通过调用 <code>alloc_netdev</code> 或类似的函数来分配和初始化网络设备的数据结构。当不再需要该网络设备时，可以使用 <code>free_netdev</code> 函数来释放它所占用的资源。</p>
<p><code>free_netdev</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向要释放的网络设备的指针。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev</span></span><br><span class="line"></span><br><span class="line">free_netdev(my_dev);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个指向已经初始化的网络设备的指针。通过调用 <code>free_netdev</code> 函数，我们释放了该网络设备所占用的资源，并销毁了该设备的数据结构。</p>
<p>在释放网络设备之后，你将无法再使用该设备进行网络数据的传输和处理。</p>
<h3 id="spin-lock-irqsave"><a href="#spin-lock-irqsave" class="headerlink" title="spin_lock_irqsave"></a>spin_lock_irqsave</h3><p><code>spin_lock_irqsave</code> 是一个函数，用于在禁用本地中断的情况下获取自旋锁。</p>
<p>自旋锁是一种用于保护共享资源的同步机制。当多个执行单元（如线程或中断处理程序）需要访问共享资源时，它们必须先获取自旋锁，以确保互斥访问。</p>
<p><code>spin_lock_irqsave</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">spin_lock_irqsave</span><span class="params">(<span class="type">spinlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>lock</code> 是一个指向自旋锁的指针，表示要获取的自旋锁。</p>
<p>参数 <code>flags</code> 是一个标志变量，用于保存中断状态。在获取自旋锁之前，函数会禁用本地中断，并将当前中断状态保存到 <code>flags</code> 变量中。在释放自旋锁后，函数会根据 <code>flags</code> 变量的值来恢复中断状态。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">spinlock_t</span> my_lock;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;my_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里执行需要保护的代码</span></span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;my_lock, flags);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_lock</code> 是一个已经定义和初始化的自旋锁。通过调用 <code>spin_lock_irqsave</code> 函数，我们在禁用本地中断的情况下获取了自旋锁，并将当前中断状态保存到 <code>flags</code> 变量中。在保护的代码执行完毕后，我们使用 <code>spin_unlock_irqrestore</code> 函数来释放自旋锁并恢复中断状态。</p>
<p>使用 <code>spin_lock_irqsave</code> 函数时，需要注意避免死锁和长时间持有自旋锁的情况，以避免影响系统的响应性能。</p>
<h3 id="spin-unlock-irqrestore"><a href="#spin-unlock-irqrestore" class="headerlink" title="spin_unlock_irqrestore"></a>spin_unlock_irqrestore</h3><p><code>spin_unlock_irqrestore</code> 是一个函数，用于释放自旋锁并恢复中断状态。</p>
<p>自旋锁是一种用于保护共享资源的同步机制。当多个执行单元（如线程或中断处理程序）需要访问共享资源时，它们必须先获取自旋锁，以确保互斥访问。当完成对共享资源的访问后，就可以使用 <code>spin_unlock_irqrestore</code> 函数来释放自旋锁并恢复中断状态。</p>
<p><code>spin_unlock_irqrestore</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock_irqrestore</span><span class="params">(<span class="type">spinlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>lock</code> 是一个指向要释放的自旋锁的指针。</p>
<p>参数 <code>flags</code> 是一个保存中断状态的标志变量。该变量应该是在获取自旋锁时通过 <code>spin_lock_irqsave</code> 函数保存的中断状态。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">spinlock_t</span> my_lock;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;my_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里执行需要保护的代码</span></span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;my_lock, flags);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_lock</code> 是一个已经定义和初始化的自旋锁。通过调用 <code>spin_lock_irqsave</code> 函数，我们在禁用本地中断的情况下获取了自旋锁，并将当前中断状态保存到 <code>flags</code> 变量中。在保护的代码执行完毕后，我们使用 <code>spin_unlock_irqrestore</code> 函数来释放自旋锁并恢复中断状态。</p>
<p>使用 <code>spin_unlock_irqrestore</code> 函数时，需要确保与获取自旋锁的函数 <code>spin_lock_irqsave</code> 成对使用，以避免中断状态的错误恢复。</p>
<h3 id="napi-schedule"><a href="#napi-schedule" class="headerlink" title="napi_schedule"></a>napi_schedule</h3><p><code>napi_schedule</code> 是一个函数，用于调度 NAPI（Network API）处理程序以在稍后的时机执行。</p>
<p>NAPI 是 Linux 内核中的一种网络处理机制，用于提高网络数据包处理的效率。它通过将网络接口的中断处理推迟到稍后的时机执行，从而减少了中断处理的频率，提高了系统的性能。</p>
<p><code>napi_schedule</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">napi_schedule</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>napi</code> 是一个指向 NAPI 结构的指针，表示要调度的 NAPI 处理程序。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> <span class="title">my_napi</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_napi</span></span><br><span class="line"></span><br><span class="line">napi_schedule(&amp;my_napi);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_napi</code> 是一个已经定义和初始化的 NAPI 结构。通过调用 <code>napi_schedule</code> 函数，我们调度了 <code>my_napi</code> 中的 NAPI 处理程序以在稍后的时机执行。</p>
<p>使用 <code>napi_schedule</code> 函数时，需要确保在合适的时机调用它，以确保网络数据包的及时处理。</p>
<h3 id="schedule-work"><a href="#schedule-work" class="headerlink" title="schedule_work"></a>schedule_work</h3><p><code>schedule_work</code> 是一个函数，用于将工作队列（workqueue）中的工作项安排在稍后的时机执行。</p>
<p>工作队列是 Linux 内核中的一种机制，用于在后台执行延迟的工作任务。通过将工作项添加到工作队列中，可以在系统的空闲时间执行这些工作项，从而减少对主处理器的负载。</p>
<p><code>schedule_work</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>work</code> 是一个指向工作项（work_struct）的指针，表示要安排执行的工作项。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">my_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_work</span></span><br><span class="line"></span><br><span class="line">schedule_work(&amp;my_work);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_work</code> 是一个已经定义和初始化的工作项。通过调用 <code>schedule_work</code> 函数，我们将 <code>my_work</code> 添加到工作队列中，以在稍后的时机执行。</p>
<p>使用 <code>schedule_work</code> 函数时，需要确保在适当的时机调用它，以便工作项能够按照预期执行。</p>
<h3 id="netif-queue-stopped"><a href="#netif-queue-stopped" class="headerlink" title="netif_queue_stopped"></a>netif_queue_stopped</h3><p><code>netif_queue_stopped</code> 是一个函数，用于检查网络接口队列是否被停止。</p>
<p>在 Linux 内核中，网络接口队列用于存储要发送的网络数据包。当网络接口队列被停止时，新的数据包将无法被发送。</p>
<p><code>netif_queue_stopped</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">netif_queue_stopped</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向网络设备的指针，表示要检查的网络接口。</p>
<p>函数返回值为 0 表示网络接口队列没有被停止，非零值表示网络接口队列已被停止。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (netif_queue_stopped(my_dev)) &#123;</span><br><span class="line">    <span class="comment">// 网络接口队列已停止</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 网络接口队列未停止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个已经定义和初始化的网络设备。通过调用 <code>netif_queue_stopped</code> 函数，我们检查了 <code>my_dev</code> 所对应的网络接口队列是否被停止。</p>
<p>使用 <code>netif_queue_stopped</code> 函数时，需要确保在适当的时机调用它，以便根据需要采取相应的操作。</p>
<h3 id="netif-wake-queue"><a href="#netif-wake-queue" class="headerlink" title="netif_wake_queue"></a>netif_wake_queue</h3><p><code>netif_wake_queue</code> 是一个函数，用于唤醒网络接口队列，使其可以继续发送数据包。</p>
<p>在 Linux 内核中，网络接口队列用于存储要发送的网络数据包。当网络接口队列被停止时，新的数据包将无法被发送。<code>netif_wake_queue</code> 函数可以用来唤醒被停止的网络接口队列，以便继续发送数据包。</p>
<p><code>netif_wake_queue</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_wake_queue</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向网络设备的指针，表示要唤醒的网络接口。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev</span></span><br><span class="line"></span><br><span class="line">netif_wake_queue(my_dev);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个已经定义和初始化的网络设备。通过调用 <code>netif_wake_queue</code> 函数，我们唤醒了 <code>my_dev</code> 对应的网络接口队列，使其可以继续发送数据包。</p>
<p>使用 <code>netif_wake_queue</code> 函数时，需要确保在适当的时机调用它，以便根据需要唤醒网络接口队列。</p>
<h3 id="napi-enable"><a href="#napi-enable" class="headerlink" title="napi_enable"></a>napi_enable</h3><p><code>napi_enable</code> 是一个函数，用于启用 NAPI（New API）机制，以在网络驱动程序中启用中断处理。</p>
<p>在 Linux 内核中，NAPI 是一种用于网络驱动程序的高性能中断处理机制。它通过在中断处理程序中禁用中断并延迟网络接收处理，以减少中断处理的开销。然后，通过调用 <code>napi_enable</code> 函数，可以启用 NAPI 机制，以便在需要时在软中断上下文中进行网络接收处理。</p>
<p><code>napi_enable</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">napi_enable</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>napi</code> 是一个指向 <code>napi_struct</code> 结构体的指针，表示要启用的 NAPI 实例。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> <span class="title">my_napi</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_napi</span></span><br><span class="line"></span><br><span class="line">napi_enable(&amp;my_napi);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_napi</code> 是一个已经定义和初始化的 <code>napi_struct</code> 结构体实例。通过调用 <code>napi_enable</code> 函数，我们启用了 <code>my_napi</code> 对应的 NAPI 机制，以便在软中断上下文中进行网络接收处理。</p>
<p>使用 <code>napi_enable</code> 函数时，需要确保在适当的时机调用它，以便正确启用 NAPI 机制。</p>
<h3 id="napi-disable"><a href="#napi-disable" class="headerlink" title="napi_disable"></a>napi_disable</h3><p><code>napi_disable</code> 是一个函数，用于禁用 NAPI（New API）机制。</p>
<p>NAPI 是 Linux 内核中用于网络驱动程序的一种机制，旨在提高网络数据包处理的效率。通过使用 NAPI，驱动程序可以在接收数据包时批量处理，减少中断处理的开销，提高系统的吞吐量。</p>
<p><code>napi_disable</code> 函数可以用来禁用 NAPI 机制，即停止驱动程序使用 NAPI 进行数据包处理。</p>
<p><code>napi_disable</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">napi_disable</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>napi</code> 是一个指向 <code>napi_struct</code> 结构体的指针，表示要禁用的 NAPI 实例。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> <span class="title">my_napi</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_napi</span></span><br><span class="line"></span><br><span class="line">napi_disable(&amp;my_napi);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_napi</code> 是一个已经定义和初始化的 <code>napi_struct</code> 结构体实例。通过调用 <code>napi_disable</code> 函数，我们禁用了 <code>my_napi</code> 对应的 NAPI 实例。</p>
<p>使用 <code>napi_disable</code> 函数时，需要确保在适当的时机调用它，以便正确禁用 NAPI 机制。</p>
<h3 id="INIT-WORK"><a href="#INIT-WORK" class="headerlink" title="INIT_WORK"></a>INIT_WORK</h3><p><code>INIT_WORK</code> 是一个宏，用于初始化一个工作队列（workqueue）中的工作项（work item）。</p>
<p>在 Linux 内核中，工作队列是一种异步执行任务的机制。工作项表示一个要执行的具体任务，并将被添加到工作队列中等待执行。</p>
<p><code>INIT_WORK</code> 宏的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">INIT_WORK</span><span class="params">(<span class="keyword">struct</span> work_struct *work, <span class="type">void</span> (*func)(<span class="keyword">struct</span> work_struct *work))</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>work</code> 是一个指向 <code>work_struct</code> 结构体的指针，表示要初始化的工作项。参数 <code>func</code> 是一个指向函数的指针，表示工作项的处理函数。该函数将在工作项被调度执行时被调用。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">my_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义工作项处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_work_handler</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行工作项的具体任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化工作项</span></span><br><span class="line">INIT_WORK(&amp;my_work, my_work_handler);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个名为 <code>my_work</code> 的工作项，并定义了一个名为 <code>my_work_handler</code> 的函数作为工作项的处理函数。通过调用 <code>INIT_WORK</code> 宏，我们将 <code>my_work</code> 工作项与 <code>my_work_handler</code> 处理函数关联起来，以便在工作队列中执行。</p>
<p>使用 <code>INIT_WORK</code> 宏时，需要确保在适当的时机调用它，以便正确初始化工作项。</p>
<h3 id="netif-tx-start-all-queues"><a href="#netif-tx-start-all-queues" class="headerlink" title="netif_tx_start_all_queues"></a>netif_tx_start_all_queues</h3><p><code>netif_tx_start_all_queues</code> 是一个函数，用于启动网络设备中的所有发送队列。</p>
<p>在 Linux 内核中，网络设备可以具有多个发送队列，用于并行发送数据包。<code>netif_tx_start_all_queues</code> 函数可以用来启动网络设备中的所有发送队列，使其可以开始发送数据包。</p>
<p><code>netif_tx_start_all_queues</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_tx_start_all_queues</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向网络设备的指针，表示要启动发送队列的网络设备。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev</span></span><br><span class="line"></span><br><span class="line">netif_tx_start_all_queues(my_dev);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个已经定义和初始化的网络设备。通过调用 <code>netif_tx_start_all_queues</code> 函数，我们启动了 <code>my_dev</code> 对应的所有发送队列，使其可以开始发送数据包。</p>
<p>使用 <code>netif_tx_start_all_queues</code> 函数时，需要确保在适当的时机调用它，以便根据需要启动发送队列。</p>
<h3 id="netif-carrier-on"><a href="#netif-carrier-on" class="headerlink" title="netif_carrier_on"></a>netif_carrier_on</h3><p><code>netif_carrier_on</code> 是一个函数，用于将网络设备的 carrier 状态设置为开启。</p>
<p>在 Linux 内核中，网络设备的 carrier 状态表示设备是否连接到物理网络。当 carrier 状态为开启时，表示设备已经连接到了物理网络；反之，当 carrier 状态为关闭时，表示设备未连接到物理网络。</p>
<p><code>netif_carrier_on</code> 函数可以用来将网络设备的 carrier 状态设置为开启。</p>
<p><code>netif_carrier_on</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_carrier_on</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向网络设备的指针，表示要设置 carrier 状态的网络设备。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev</span></span><br><span class="line"></span><br><span class="line">netif_carrier_on(my_dev);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个已经定义和初始化的网络设备。通过调用 <code>netif_carrier_on</code> 函数，我们将 <code>my_dev</code> 对应的 carrier 状态设置为开启。</p>
<p>使用 <code>netif_carrier_on</code> 函数时，需要确保在适当的时机调用它，以便正确设置 carrier 状态。</p>
<h3 id="netif-tx-stop-all-queues"><a href="#netif-tx-stop-all-queues" class="headerlink" title="netif_tx_stop_all_queues"></a>netif_tx_stop_all_queues</h3><p><code>netif_tx_stop_all_queues</code> 是一个函数，用于停止网络设备中的所有发送队列。</p>
<p>在 Linux 内核中，网络设备可以具有多个发送队列，用于并行发送数据包。<code>netif_tx_stop_all_queues</code> 函数可以用来停止网络设备中的所有发送队列，使其停止发送数据包。</p>
<p><code>netif_tx_stop_all_queues</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_tx_stop_all_queues</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向网络设备的指针，表示要停止发送队列的网络设备。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev</span></span><br><span class="line"></span><br><span class="line">netif_tx_stop_all_queues(my_dev);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个已经定义和初始化的网络设备。通过调用 <code>netif_tx_stop_all_queues</code> 函数，我们停止了 <code>my_dev</code> 对应的所有发送队列，使其停止发送数据包。</p>
<p>使用 <code>netif_tx_stop_all_queues</code> 函数时，需要确保在适当的时机调用它，以便根据需要停止发送队列。</p>
<h3 id="netif-tx-stop-queue"><a href="#netif-tx-stop-queue" class="headerlink" title="netif_tx_stop_queue"></a>netif_tx_stop_queue</h3><p><code>netif_tx_stop_queue</code> 是一个函数，用于停止指定网络设备上的发送队列。</p>
<p>在 Linux 内核中，网络设备代表计算机系统中的网络接口，用于发送和接收网络数据。每个网络设备通常有多个发送队列，用于并行发送数据。</p>
<p><code>netif_tx_stop_queue</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_tx_stop_queue</span><span class="params">(<span class="keyword">struct</span> netdev_queue *<span class="built_in">queue</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>queue</code> 是一个指向 <code>netdev_queue</code> 结构体的指针，表示要停止的发送队列。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netdev_queue</span> *<span class="title">my_queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_queue</span></span><br><span class="line"></span><br><span class="line">netif_tx_stop_queue(my_queue);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_queue</code> 是一个已经定义和初始化的发送队列。通过调用 <code>netif_tx_stop_queue</code> 函数，我们停止了该发送队列上的数据发送。</p>
<p>当发送队列被停止后，网络设备将不再发送该队列上的数据包，直到调用 <code>netif_tx_start_queue</code> 函数重新启动队列。</p>
<h3 id="netif-carrier-off"><a href="#netif-carrier-off" class="headerlink" title="netif_carrier_off"></a>netif_carrier_off</h3><p><code>netif_carrier_off</code> 是一个函数，用于将网络设备的 carrier 状态设置为关闭。</p>
<p>在 Linux 内核中，网络设备的 carrier 状态表示设备是否连接到物理网络。当 carrier 状态为开启时，表示设备已经连接到了物理网络；反之，当 carrier 状态为关闭时，表示设备未连接到物理网络。</p>
<p><code>netif_carrier_off</code> 函数可以用来将网络设备的 carrier 状态设置为关闭。</p>
<p><code>netif_carrier_off</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_carrier_off</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向网络设备的指针，表示要设置 carrier 状态的网络设备。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev</span></span><br><span class="line"></span><br><span class="line">netif_carrier_off(my_dev);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个已经定义和初始化的网络设备。通过调用 <code>netif_carrier_off</code> 函数，我们将 <code>my_dev</code> 对应的 carrier 状态设置为关闭。</p>
<p>使用 <code>netif_carrier_off</code> 函数时，需要确保在适当的时机调用它，以便正确设置 carrier 状态。</p>
<h3 id="dma-sync-single-for-cpu"><a href="#dma-sync-single-for-cpu" class="headerlink" title="dma_sync_single_for_cpu"></a>dma_sync_single_for_cpu</h3><p><code>dma_sync_single_for_cpu</code> 是一个函数，用于同步单个 DMA 缓冲区的数据，以便 CPU 可以安全地访问该缓冲区。</p>
<p>在使用 DMA（Direct Memory Access）进行数据传输时，为了保证数据的一致性和正确性，需要进行 DMA 缓冲区与 CPU 内存之间的数据同步。<code>dma_sync_single_for_cpu</code> 函数用于对单个 DMA 缓冲区进行同步操作，以便 CPU 可以安全地读取该缓冲区的数据。</p>
<p><code>dma_sync_single_for_cpu</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dma_sync_single_for_cpu</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">dma_addr_t</span> dma_handle, <span class="type">size_t</span> size, <span class="keyword">enum</span> dma_data_direction direction)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向设备的指针，表示与 DMA 缓冲区相关联的设备。</p>
<p>参数 <code>dma_handle</code> 是 DMA 缓冲区的物理地址。</p>
<p>参数 <code>size</code> 是 DMA 缓冲区的大小（以字节为单位）。</p>
<p>参数 <code>direction</code> 是数据传输的方向，可以是 <code>DMA_TO_DEVICE</code>（从内存到设备）或 <code>DMA_FROM_DEVICE</code>（从设备到内存）。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/dma-mapping.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">my_dev</span>;</span></span><br><span class="line"><span class="type">dma_addr_t</span> dma_addr;</span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">dma_data_direction</span> <span class="title">direction</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_dev, dma_addr, size 和 direction</span></span><br><span class="line"></span><br><span class="line">dma_sync_single_for_cpu(my_dev, dma_addr, size, direction);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_dev</code> 是一个已经定义和初始化的设备，<code>dma_addr</code> 是 DMA 缓冲区的物理地址，<code>size</code> 是 DMA 缓冲区的大小，<code>direction</code> 是数据传输的方向。通过调用 <code>dma_sync_single_for_cpu</code> 函数，我们对指定的 DMA 缓冲区进行了同步操作。</p>
<p>使用 <code>dma_sync_single_for_cpu</code> 函数时，需要确保在适当的时机调用它，以便正确进行数据同步。</p>
<h3 id="skb-put"><a href="#skb-put" class="headerlink" title="skb_put"></a>skb_put</h3><p><code>skb_put</code> 是一个函数，用于向 Linux 内核的套接字缓冲区（socket buffer）中添加数据。</p>
<p>在 Linux 内核中，套接字缓冲区是用于存储网络数据的数据结构。<code>skb_put</code> 函数可以用于将数据添加到套接字缓冲区的末尾，并更新相关的指针和长度信息。</p>
<p><code>skb_put</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_put</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>skb</code> 是一个指向套接字缓冲区（<code>sk_buff</code> 结构体）的指针，表示要添加数据的缓冲区。</p>
<p>参数 <code>len</code> 是要添加的数据的长度（以字节为单位）。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">my_skb</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_skb, data 和 len</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *new_data = skb_put(my_skb, len);</span><br><span class="line"><span class="built_in">memcpy</span>(new_data, data, len);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_skb</code> 是一个已经定义和初始化的套接字缓冲区，<code>data</code> 是要添加的数据，<code>len</code> 是数据的长度。通过调用 <code>skb_put</code> 函数，我们将 <code>len</code> 长度的数据添加到了 <code>my_skb</code> 缓冲区的末尾，并返回一个指向新添加数据的起始位置的指针。然后，我们可以使用 <code>memcpy</code> 函数将数据拷贝到该位置。</p>
<p>使用 <code>skb_put</code> 函数时，需要确保在适当的时机调用它，以便正确添加数据并更新相关的指针和长度信息。</p>
<h3 id="skb-record-rx-queue"><a href="#skb-record-rx-queue" class="headerlink" title="skb_record_rx_queue"></a>skb_record_rx_queue</h3><p><code>skb_record_rx_queue</code> 是一个函数，用于记录接收队列（RX queue）在套接字缓冲区（socket buffer）中的信息。</p>
<p>在 Linux 内核中，套接字缓冲区是用于存储网络数据的数据结构。<code>skb_record_rx_queue</code> 函数可以用于记录接收队列在套接字缓冲区中的信息，以便后续处理和分析。</p>
<p><code>skb_record_rx_queue</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skb_record_rx_queue</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, u16 rx_queue)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>skb</code> 是一个指向套接字缓冲区（<code>sk_buff</code> 结构体）的指针，表示要记录接收队列信息的缓冲区。</p>
<p>参数 <code>rx_queue</code> 是接收队列的标识符，通常是一个无符号 16 位整数。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">my_skb</span>;</span></span><br><span class="line">u16 rx_queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_skb 和 rx_queue</span></span><br><span class="line"></span><br><span class="line">skb_record_rx_queue(my_skb, rx_queue);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_skb</code> 是一个已经定义和初始化的套接字缓冲区，<code>rx_queue</code> 是接收队列的标识符。通过调用 <code>skb_record_rx_queue</code> 函数，我们记录了 <code>rx_queue</code> 对应的接收队列信息到 <code>my_skb</code> 缓冲区中。</p>
<p>使用 <code>skb_record_rx_queue</code> 函数时，需要确保在适当的时机调用它，以便正确记录接收队列信息。</p>
<h3 id="skb-get-queue-mapping"><a href="#skb-get-queue-mapping" class="headerlink" title="skb_get_queue_mapping"></a>skb_get_queue_mapping</h3><p><code>skb_get_queue_mapping</code> 是一个函数，用于获取给定网络数据包（socket buffer）的队列映射（queue mapping）。在 Linux 内核中，网络数据包可以被分配到不同的队列上进行处理，以实现负载均衡或者多队列处理。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">skb_get_queue_mapping</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>skb</code> 是一个指向 <code>struct sk_buff</code> 结构的指针，该结构表示网络数据包。函数返回一个无符号整数，表示数据包所分配的队列映射。</p>
<p>当网络数据包被送入网络设备进行发送或接收时，内核会根据一定的规则将其分配到一个特定的队列上。这个规则可以基于数据包的源 IP 地址、目标 IP 地址、协议类型、端口等信息进行判断。<code>skb_get_queue_mapping</code> 函数可以用来查询数据包所分配的队列映射。</p>
<p>使用 <code>skb_get_queue_mapping</code> 函数的一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span>  <span class="comment">// 假设有一个网络数据包</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> queue_mapping = skb_get_queue_mapping(skb);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用 <code>skb_get_queue_mapping</code> 函数获取了网络数据包 <code>skb</code> 的队列映射，并将结果存储在 <code>queue_mapping</code> 变量中。</p>
<h3 id="napi-gro-receive"><a href="#napi-gro-receive" class="headerlink" title="napi_gro_receive"></a>napi_gro_receive</h3><p><code>napi_gro_receive</code> 是一个函数，用于在 Linux 内核中执行网络报文接收和处理的操作。</p>
<p>在 Linux 内核中，NAPI（New API）是一种网络中断处理机制，用于处理高速网络设备的数据包接收。<code>napi_gro_receive</code> 函数是 NAPI 机制中的一部分，用于执行数据包接收和 GRO（Generic Receive Offload）处理。</p>
<p><code>napi_gro_receive</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">napi_gro_receive</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi, <span class="keyword">struct</span> sk_buff *skb)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>napi</code> 是一个指向 <code>napi_struct</code> 结构体的指针，表示 NAPI 上下文。</p>
<p>参数 <code>skb</code> 是一个指向套接字缓冲区（<code>sk_buff</code> 结构体）的指针，表示要处理的网络数据包。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> <span class="title">my_napi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">my_skb</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_napi 和 my_skb</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = napi_gro_receive(&amp;my_napi, my_skb);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理接收错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_napi</code> 是一个已经定义和初始化的 NAPI 上下文，<code>my_skb</code> 是一个已经定义和初始化的套接字缓冲区。通过调用 <code>napi_gro_receive</code> 函数，我们将 <code>my_skb</code> 中的网络数据包传递给 NAPI 机制进行接收和 GRO 处理。</p>
<p><code>napi_gro_receive</code> 函数返回一个整数值，表示操作的结果。通常情况下，返回值为 0 表示成功，其他值表示发生错误。</p>
<h3 id="atomic-read"><a href="#atomic-read" class="headerlink" title="atomic_read"></a>atomic_read</h3><p><code>atomic_read</code> 是一个函数，用于以原子方式读取一个原子变量的值。</p>
<p>在并发编程中，原子操作是指不会被中断的操作，可以保证在多线程或多进程环境下的正确性。原子变量是一种特殊类型的变量，可以以原子方式进行读取和修改，以避免竞态条件（race condition）和数据不一致性的问题。</p>
<p><code>atomic_read</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atomic_read</span><span class="params">(<span class="type">const</span> <span class="type">atomic_t</span> *v)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>v</code> 是一个指向 <code>atomic_t</code> 类型的原子变量的指针，表示要读取的原子变量。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">atomic_t</span> my_atomic_var;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_atomic_var</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = <span class="type">atomic_read</span>(&amp;my_atomic_var);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_atomic_var</code> 是一个已经定义和初始化的原子变量。通过调用 <code>atomic_read</code> 函数，我们以原子方式读取了 <code>my_atomic_var</code> 的值，并将其存储在 <code>value</code> 变量中。</p>
<p><code>atomic_read</code> 函数返回一个整数值，表示读取的原子变量的值。</p>
<h3 id="netdev-get-tx-queue"><a href="#netdev-get-tx-queue" class="headerlink" title="netdev_get_tx_queue"></a>netdev_get_tx_queue</h3><p><code>netdev_get_tx_queue</code> 是一个函数，用于获取网络设备（network device）指定发送队列（transmit queue）的指针。</p>
<p>在 Linux 内核中，网络设备代表计算机系统中的网络接口，用于发送和接收网络数据。每个网络设备通常有多个发送队列，用于并行发送数据。</p>
<p><code>netdev_get_tx_queue</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> netdev_queue *<span class="title function_">netdev_get_tx_queue</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="type">unsigned</span> <span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dev</code> 是一个指向 <code>net_device</code> 结构体的指针，表示要获取发送队列的网络设备。</p>
<p>参数 <code>index</code> 是一个无符号整数，表示要获取的发送队列的索引。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">my_netdev</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> queue_index;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_netdev 和 queue_index</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netdev_queue</span> *<span class="title">tx_queue</span> =</span> netdev_get_tx_queue(my_netdev, queue_index);</span><br><span class="line"><span class="keyword">if</span> (tx_queue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_netdev</code> 是一个已经定义和初始化的网络设备，<code>queue_index</code> 是要获取的发送队列的索引。通过调用 <code>netdev_get_tx_queue</code> 函数，我们获取了 <code>my_netdev</code> 中指定索引的发送队列的指针。</p>
<p><code>netdev_get_tx_queue</code> 函数返回一个指向 <code>netdev_queue</code> 结构体的指针，表示获取的发送队列。如果发送队列不存在或发生错误，返回值将为 <code>NULL</code>。</p>
<h3 id="READ-ONCE"><a href="#READ-ONCE" class="headerlink" title="READ_ONCE"></a>READ_ONCE</h3><p><code>READ_ONCE</code> 是一个宏，用于在多线程或并发环境下读取变量的值，以确保以原子方式读取变量的值。它被广泛用于 Linux 内核代码中，特别是在读取共享变量时。</p>
<p><code>READ_ONCE</code> 宏的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> READ_ONCE(x) (*((volatile typeof(x) *)&amp;(x)))</span></span><br></pre></td></tr></table></figure>

<p>它接受一个变量 <code>x</code> 作为参数，并将其强制转换为 <code>volatile</code> 类型的指针，并使用间接引用操作符 <code>*</code> 来读取该指针指向的值。通过将变量声明为 <code>volatile</code>，可以确保编译器不会对该变量的读取进行优化，以避免可能的数据不一致问题。</p>
<p>在多线程或并发环境中，如果一个线程在读取共享变量的过程中，另一个线程同时对该变量进行写操作，那么读取操作可能会得到不一致的或过期的值。使用 <code>READ_ONCE</code> 宏可以帮助确保读取操作以原子方式进行，从而避免这种情况。</p>
<p>以下是一个示例，展示了如何使用 <code>READ_ONCE</code> 宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> shared_variable = <span class="number">0</span>;  <span class="comment">// 假设有一个共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个线程中读取共享变量的值</span></span><br><span class="line"><span class="type">int</span> value = READ_ONCE(shared_variable);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用 <code>READ_ONCE</code> 宏读取了共享变量 <code>shared_variable</code> 的值，并将结果存储在 <code>value</code> 变量中。</p>
<p>请注意，<code>READ_ONCE</code> 宏仅提供了一种读取变量的原子操作的机制，并不能解决所有并发问题。在多线程或并发环境中，仍然需要使用适当的同步机制（如互斥锁、原子操作等）来确保线程安全性。</p>
<h3 id="WRITE-ONCE"><a href="#WRITE-ONCE" class="headerlink" title="WRITE_ONCE"></a>WRITE_ONCE</h3><p><code>WRITE_ONCE</code> 是一个宏，用于以原子方式写入一个变量的值，确保该操作是不可中断的。</p>
<p>在并发编程中，原子操作是指不会被中断的操作，可以保证在多线程或多进程环境下的正确性。<code>WRITE_ONCE</code> 宏可以用于以原子方式写入变量的值，以避免竞态条件（race condition）和数据不一致性的问题。</p>
<p><code>WRITE_ONCE</code> 宏的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_ONCE(var, val) (*((volatile typeof(val) *)&amp;(var)) = (val))</span></span><br></pre></td></tr></table></figure>

<p>参数 <code>var</code> 是要写入的变量，<code>val</code> 是要写入的值。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> my_variable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_variable</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> new_value = <span class="number">42</span>;</span><br><span class="line">WRITE_ONCE(my_variable, new_value);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>my_variable</code> 是一个已经定义和初始化的变量。通过调用 <code>WRITE_ONCE</code> 宏，我们以原子方式将 <code>new_value</code> 的值写入 <code>my_variable</code>。</p>
<p>使用 <code>WRITE_ONCE</code> 宏可以确保写入操作是以原子方式进行的，不会被中断或被其他线程干扰。</p>
<p>需要注意的是，<code>WRITE_ONCE</code> 宏并不能保证变量的写入操作对其他线程是可见的。如果需要保证可见性，可能需要使用其他机制，如使用适当的内存屏障或同步原语。</p>
<h3 id="eth-hdr"><a href="#eth-hdr" class="headerlink" title="eth_hdr"></a>eth_hdr</h3><p><code>eth_hdr</code> 是一个结构体，用于表示以太网帧（Ethernet frame）的头部。</p>
<p>在网络通信中，以太网是一种常见的局域网（LAN）技术，用于在计算机之间传输数据。以太网帧是以太网通信中的基本数据单元，由头部和数据部分组成。</p>
<p><code>eth_hdr</code> 结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> h_dest[ETH_ALEN];      <span class="comment">// 目的 MAC 地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> h_source[ETH_ALEN];    <span class="comment">// 源 MAC 地址</span></span><br><span class="line">    __be16 h_proto;                      <span class="comment">// 协议类型</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<p><code>ethhdr</code> 结构体的成员包括：</p>
<ul>
<li><code>h_dest</code>：目的 MAC 地址，由 6 个字节组成。</li>
<li><code>h_source</code>：源 MAC 地址，由 6 个字节组成。</li>
<li><code>h_proto</code>：协议类型，表示以太网帧中的上层协议，以 16 位无符号整数表示（使用网络字节序）。</li>
</ul>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> <span class="title">my_eth_header</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 my_eth_header</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置目的 MAC 地址</span></span><br><span class="line">my_eth_header.h_dest[<span class="number">0</span>] = <span class="number">0x12</span>;</span><br><span class="line">my_eth_header.h_dest[<span class="number">1</span>] = <span class="number">0x34</span>;</span><br><span class="line">my_eth_header.h_dest[<span class="number">2</span>] = <span class="number">0x56</span>;</span><br><span class="line">my_eth_header.h_dest[<span class="number">3</span>] = <span class="number">0x78</span>;</span><br><span class="line">my_eth_header.h_dest[<span class="number">4</span>] = <span class="number">0x9a</span>;</span><br><span class="line">my_eth_header.h_dest[<span class="number">5</span>] = <span class="number">0xbc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置源 MAC 地址</span></span><br><span class="line">my_eth_header.h_source[<span class="number">0</span>] = <span class="number">0xde</span>;</span><br><span class="line">my_eth_header.h_source[<span class="number">1</span>] = <span class="number">0xf0</span>;</span><br><span class="line">my_eth_header.h_source[<span class="number">2</span>] = <span class="number">0x12</span>;</span><br><span class="line">my_eth_header.h_source[<span class="number">3</span>] = <span class="number">0x34</span>;</span><br><span class="line">my_eth_header.h_source[<span class="number">4</span>] = <span class="number">0x56</span>;</span><br><span class="line">my_eth_header.h_source[<span class="number">5</span>] = <span class="number">0x78</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置协议类型（例如 IP 协议类型为 0x0800）</span></span><br><span class="line">my_eth_header.h_proto = htons(<span class="number">0x0800</span>);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用 <code>ethhdr</code> 结构体定义了一个名为 <code>my_eth_header</code> 的以太网帧头部。通过设置结构体的成员，我们可以初始化目的 MAC 地址、源 MAC 地址和协议类型。</p>
<h3 id="is-valid-ether-addr"><a href="#is-valid-ether-addr" class="headerlink" title="is_valid_ether_addr"></a>is_valid_ether_addr</h3><p><code>is_valid_ether_addr</code> 是一个函数或方法的名称，用于验证以太网（Ethernet）地址的有效性。</p>
<p>以太网地址是一个 48 位的物理地址，通常以十六进制表示，由 6 个字节组成，每个字节之间用冒号或连字符分隔。例如，<code>00:1A:2B:3C:4D:5E</code> 或 <code>00-1A-2B-3C-4D-5E</code>。</p>
<p><code>is_valid_ether_addr</code> 函数可以用于检查给定的字符串是否符合以太网地址的格式和规范。它通常会执行以下检查：</p>
<ol>
<li>确保字符串长度为 17 个字符（包括分隔符）。</li>
<li>确保分隔符的位置正确（每隔两个字符有一个分隔符）。</li>
<li>确保每个字节的值在合法范围内（0x00 到 0xFF）。</li>
</ol>
<h3 id="is-multicast-ether-addr"><a href="#is-multicast-ether-addr" class="headerlink" title="is_multicast_ether_addr"></a>is_multicast_ether_addr</h3><p><code>is_multicast_ether_addr</code> 是一个函数，用于检查给定的以太网 MAC 地址是否为多播地址。</p>
<p>在以太网通信中，MAC 地址是用于唯一标识网络设备的硬件地址。其中，多播地址是一种特殊的 MAC 地址，用于指示数据包应该被发送到一组设备而不是单个设备。</p>
<p><code>is_multicast_ether_addr</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_multicast_ether_addr</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *addr)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>addr</code> 是一个指向以太网 MAC 地址的指针，由 6 个字节组成。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> mac_address[ETH_ALEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 mac_address</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_multicast_ether_addr(mac_address)) &#123;</span><br><span class="line">    <span class="comment">// 是多播地址</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不是多播地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>mac_address</code> 是一个已经定义和初始化的以太网 MAC 地址。通过调用 <code>is_multicast_ether_addr</code> 函数，我们检查该地址是否为多播地址。</p>
<p>如果给定的 MAC 地址是多播地址，函数将返回非零值；如果是单播地址或其他类型的地址，函数将返回零。</p>
<h3 id="skb-clone"><a href="#skb-clone" class="headerlink" title="skb_clone"></a>skb_clone</h3><p><code>skb_clone</code> 是一个函数，用于克隆一个 <code>sk_buff</code> 结构体（Socket Buffer）。</p>
<p>在 Linux 内核中，<code>sk_buff</code> 是一种用于封装网络数据包的数据结构。它包含了网络数据包的各种信息，如数据内容、协议头部、接口信息等。<code>skb_clone</code> 函数用于创建一个 <code>sk_buff</code> 结构体的副本，以便在网络协议栈中进行数据包的处理。</p>
<p><code>skb_clone</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">skb_clone</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb, <span class="type">gfp_t</span> priority)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>skb</code> 是指向要克隆的 <code>sk_buff</code> 结构体的指针，<code>priority</code> 是内存分配的优先级。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">original_skb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">cloned_skb</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 original_skb</span></span><br><span class="line"></span><br><span class="line">cloned_skb = skb_clone(original_skb, GFP_ATOMIC);</span><br><span class="line"><span class="keyword">if</span> (cloned_skb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功克隆 sk_buff</span></span><br><span class="line">    <span class="comment">// 可以对 cloned_skb 进行进一步的处理</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 克隆 sk_buff 失败</span></span><br><span class="line">    <span class="comment">// 处理错误情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>original_skb</code> 是一个已经定义和初始化的 <code>sk_buff</code> 结构体指针。通过调用 <code>skb_clone</code> 函数，我们克隆了 <code>original_skb</code>，并将克隆后的 <code>sk_buff</code> 结构体指针赋值给 <code>cloned_skb</code>。</p>
<p>如果克隆成功，函数将返回一个指向新创建的 <code>sk_buff</code> 结构体的指针；如果克隆失败，函数将返回 <code>NULL</code>。</p>
<p>需要注意的是，<code>skb_clone</code> 函数只克隆 <code>sk_buff</code> 结构体本身，不会克隆数据内容。如果需要克隆数据内容，可以使用 <code>skb_copy</code> 或 <code>skb_copy_bits</code> 函数。</p>
<h3 id="netif-running"><a href="#netif-running" class="headerlink" title="netif_running"></a>netif_running</h3><p><code>netif_running</code> 是一个函数或宏，用于检查网络接口是否处于运行状态。</p>
<p>在 Linux 内核中，网络接口是用于连接计算机与网络的物理或虚拟设备。<code>netif_running</code> 函数或宏用于检查指定的网络接口是否处于运行状态，即是否已启动。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 dev</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (netif_running(dev)) &#123;</span><br><span class="line">    <span class="comment">// 网络接口已启动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 网络接口未启动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>dev</code> 是一个已经定义和初始化的 <code>net_device</code> 结构体指针。通过调用 <code>netif_running</code> 函数或宏，我们检查指定的网络接口是否处于运行状态。</p>
<p>如果网络接口已启动，函数或宏将返回非零值；如果网络接口未启动或不存在，函数或宏将返回零。</p>
<p>需要注意的是，<code>netif_running</code> 只能检查网络接口的运行状态，而不能判断网络连接的可用性。要检查网络连接的可用性，可能需要进一步的网络层面的操作。</p>
<h3 id="dev-kfree-skb-any"><a href="#dev-kfree-skb-any" class="headerlink" title="dev_kfree_skb_any"></a>dev_kfree_skb_any</h3><p><code>dev_kfree_skb_any</code> 是一个函数，用于释放网络数据包缓冲区。</p>
<p>在 Linux 内核中，网络数据包经过网络设备的处理流程，通常会在不同的处理阶段进行缓存。<code>dev_kfree_skb_any</code> 函数用于释放这些网络数据包缓冲区，以便回收内存资源。</p>
<p><code>dev_kfree_skb_any</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dev_kfree_skb_any</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>skb</code> 是一个指向 <code>sk_buff</code> 结构体的指针，表示要释放的网络数据包缓冲区。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 skb</span></span><br><span class="line"></span><br><span class="line">dev_kfree_skb_any(skb);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们假设 <code>skb</code> 是一个已经定义和初始化的 <code>sk_buff</code> 结构体指针。通过调用 <code>dev_kfree_skb_any</code> 函数，我们释放了指定的网络数据包缓冲区。</p>
<p>需要注意的是，<code>dev_kfree_skb_any</code> 函数会根据网络数据包缓冲区的类型和属性来选择适当的释放方法。它可以用于释放通过网络设备接收的数据包缓冲区，也可以用于释放通过网络设备发送的数据包缓冲区。</p>
<h3 id="netdev-xmit-more"><a href="#netdev-xmit-more" class="headerlink" title="netdev_xmit_more"></a>netdev_xmit_more</h3><p><code>netdev_xmit_more</code> 是一个函数或标志，用于指示网络设备驱动程序在发送网络数据包后是否有更多数据要发送。这通常与网络设备驱动程序的发送函数相关联。</p>
<p>当网络设备驱动程序发送网络数据包时，它可以设置 <code>netdev_xmit_more</code> 标志来指示是否有更多的数据包要发送。如果设置了该标志，网络设备驱动程序可以继续发送后续的网络数据包，而无需等待额外的触发。</p>
<p>这个标志的具体用法和含义可能会因网络设备驱动程序的实现而有所不同。在某些情况下，网络设备驱动程序可能使用该标志来实现多队列发送，允许并行地发送多个数据包。在其他情况下，该标志可能用于指示设备驱动程序在发送数据包后是否需要进行额外的处理或操作。</p>
<p>以下是一个示例，展示了如何在网络设备驱动程序中使用 <code>netdev_xmit_more</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span>  <span class="comment">// 假设有一个网络数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 netdev_xmit_more 标志，表示还有更多数据包要发送</span></span><br><span class="line">skb-&gt;dev-&gt;xmit_more = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据包</span></span><br><span class="line"><span class="type">int</span> result = skb-&gt;dev-&gt;netdev_ops-&gt;ndo_start_xmit(skb, skb-&gt;dev);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们将 <code>netdev_xmit_more</code> 设置为 1，表示还有更多的数据包要发送。然后，我们调用网络设备驱动程序的 <code>ndo_start_xmit</code> 函数来发送数据包。网络设备驱动程序可以根据 <code>netdev_xmit_more</code> 标志来决定是否继续发送后续的数据包。</p>
<h3 id="netif-xmit-stopped"><a href="#netif-xmit-stopped" class="headerlink" title="netif_xmit_stopped"></a>netif_xmit_stopped</h3><p><code>netif_xmit_stopped</code> 是一个函数或标志，用于指示网络设备是否停止发送数据包。它通常与网络设备驱动程序的发送函数相关联。</p>
<p>当网络设备停止发送数据包时，可以设置 <code>netif_xmit_stopped</code> 标志来指示网络设备驱动程序停止发送数据包。这可能是由于网络设备的发送队列已满，或者其他原因导致无法继续发送数据包。</p>
<p>这个标志的具体用法和含义可能会因网络设备驱动程序的实现而有所不同。在某些情况下，网络设备驱动程序可能使用该标志来实现流量控制，以防止过多的数据包发送到网络。在其他情况下，该标志可能用于指示设备驱动程序在发送数据包后需要进行额外的处理或操作。</p>
<p>以下是一个示例，展示了如何在网络设备驱动程序中使用 <code>netif_xmit_stopped</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span>  <span class="comment">// 假设有一个网络数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据包</span></span><br><span class="line"><span class="type">int</span> result = skb-&gt;dev-&gt;netdev_ops-&gt;ndo_start_xmit(skb, skb-&gt;dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果发送队列已满，设置 netif_xmit_stopped 标志</span></span><br><span class="line"><span class="keyword">if</span> (result == NETDEV_TX_BUSY) &#123;</span><br><span class="line">    skb-&gt;dev-&gt;xmit_lock_owner |= __LINK_STATE_XMIT_XLOCK;</span><br><span class="line">    skb-&gt;dev-&gt;xmit_more = <span class="number">1</span>;</span><br><span class="line">    netif_tx_stop_queue(skb-&gt;dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们调用网络设备驱动程序的 <code>ndo_start_xmit</code> 函数来发送数据包。如果发送队列已满，返回值 <code>NETDEV_TX_BUSY</code> 将会被返回。在这种情况下，我们设置了 <code>netif_xmit_stopped</code> 标志，表示网络设备已停止发送数据包，并调用 <code>netif_tx_stop_queue</code> 函数来停止发送队列。</p>
<h3 id="pci-set-drvdata"><a href="#pci-set-drvdata" class="headerlink" title="pci_set_drvdata"></a>pci_set_drvdata</h3><p><code>pci_set_drvdata</code> 是一个函数，用于设置 PCI 设备的私有数据指针。在 Linux 内核中，PCI 设备结构体（<code>struct pci_dev</code>）中有一个指针成员 <code>dev_data</code>，可以用来存储与该设备相关的私有数据。</p>
<p><code>pci_set_drvdata</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pci_set_drvdata</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数：<code>pdev</code> 是指向要设置私有数据的 PCI 设备结构体的指针，<code>data</code> 是要设置的私有数据指针。</p>
<p>使用 <code>pci_set_drvdata</code> 函数可以将私有数据指针存储在 <code>pdev-&gt;dev_data</code> 中，以便在之后的代码中使用。</p>
<p>以下是一个示例，展示了如何使用 <code>pci_set_drvdata</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 其他的数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在驱动程序的初始化函数中使用 pci_set_drvdata</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_driver_probe</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配并初始化私有数据</span></span><br><span class="line">    data = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> my_data), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    data-&gt;value = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置私有数据指针</span></span><br><span class="line">    pci_set_drvdata(pdev, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他初始化操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为 <code>my_data</code> 的结构体，其中包含了与 PCI 设备相关的私有数据。在驱动程序的初始化函数 <code>my_driver_probe</code> 中，我们使用 <code>pci_set_drvdata</code> 函数将 <code>data</code> 私有数据指针存储在 <code>pdev-&gt;dev_data</code> 中。</p>
<h3 id="pci-set-master"><a href="#pci-set-master" class="headerlink" title="pci_set_master"></a>pci_set_master</h3><p><code>pci_set_master</code> 是一个函数，用于设置 PCI 设备的主控制器寄存器（Master Enable）。在 PCI 总线中，Master Enable 寄存器用于控制设备是否具有总线主控制权。</p>
<p><code>pci_set_master</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pci_set_master</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个参数 <code>pdev</code>，是指向要设置主控制器寄存器的 PCI 设备结构体的指针。</p>
<p>通过调用 <code>pci_set_master</code> 函数，可以将 PCI 设备的主控制器寄存器设置为使能状态，从而允许设备进行 DMA（Direct Memory Access）传输和总线主控制操作。</p>
<p>以下是一个示例，展示了如何使用 <code>pci_set_master</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在驱动程序的初始化函数中使用 pci_set_master</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_driver_probe</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置设备的主控制器寄存器</span></span><br><span class="line">    pci_set_master(pdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他初始化操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们在驱动程序的初始化函数 <code>my_driver_probe</code> 中调用了 <code>pci_set_master</code> 函数，以设置设备的主控制器寄存器。</p>
<p>需要注意的是，只有具有总线主控制权的设备才能发起 DMA 传输和执行总线主控制操作。因此，在需要进行这些操作的设备上，通常需要调用 <code>pci_set_master</code> 函数来启用主控制器。</p>
<h3 id="pci-request-regions"><a href="#pci-request-regions" class="headerlink" title="pci_request_regions"></a>pci_request_regions</h3><p><code>pci_request_regions</code> 是一个函数，用于请求和分配 PCI 设备的资源区域。在 Linux 内核中，PCI 设备的资源区域包括 I&#x2F;O 端口、内存地址和中断等。</p>
<p><code>pci_request_regions</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pci_request_regions</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">const</span> <span class="type">char</span> *res_name)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数：<code>pdev</code> 是指向要请求资源区域的 PCI 设备结构体的指针，<code>res_name</code> 是一个字符串，用于标识请求的资源区域。</p>
<p>通过调用 <code>pci_request_regions</code> 函数，可以请求和分配给定设备的资源区域。如果请求成功，函数会返回 0；如果请求失败，函数会返回一个负数错误码。</p>
<p>以下是一个示例，展示了如何使用 <code>pci_request_regions</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在驱动程序的初始化函数中使用 pci_request_regions</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_driver_probe</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求设备的资源区域</span></span><br><span class="line">    ret = pci_request_regions(pdev, <span class="string">&quot;my_resource&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="comment">// 资源请求失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他初始化操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们在驱动程序的初始化函数 <code>my_driver_probe</code> 中调用了 <code>pci_request_regions</code> 函数，以请求设备的资源区域，并指定了一个资源名称 “my_resource”。</p>
<p>当成功请求资源区域后，设备的资源就可以被驱动程序访问和使用。在驱动程序的退出时，应使用 <code>pci_release_regions</code> 函数释放已分配的资源区域。</p>
<h3 id="pci-resource-start"><a href="#pci-resource-start" class="headerlink" title="pci_resource_start"></a>pci_resource_start</h3><p><code>pci_resource_start</code> 是一个函数或宏，用于获取 PCI 设备资源区域的起始地址。在 Linux 内核中，PCI 设备的资源区域包括 I&#x2F;O 端口、内存地址和中断等。</p>
<p><code>pci_resource_start</code> 的使用方式有两种：</p>
<ol>
<li><p>作为函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">resource_size_t</span> <span class="title function_">pci_resource_start</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">int</span> bar)</span>;</span><br></pre></td></tr></table></figure>
<p>它接受两个参数：<code>pdev</code> 是指向 PCI 设备结构体的指针，<code>bar</code> 是指定的资源区域索引。</p>
</li>
<li><p>作为宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pci_resource_start(pdev, bar) (pdev)-&gt;resource[(bar)].start</span></span><br></pre></td></tr></table></figure>
<p>它直接返回指定资源区域的起始地址。</p>
</li>
</ol>
<p><code>pci_resource_start</code> 可以用于获取指定 PCI 设备资源区域的起始地址，以便驱动程序可以访问和使用该资源。</p>
<p>以下是一个示例，展示了如何使用 <code>pci_resource_start</code> 函数或宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在驱动程序中使用 pci_resource_start 获取指定资源区域的起始地址</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_driver_probe</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">resource_size_t</span> start_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设备的第一个资源区域的起始地址</span></span><br><span class="line">    start_addr = pci_resource_start(pdev, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用起始地址进行其他操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们在驱动程序的初始化函数 <code>my_driver_probe</code> 中调用了 <code>pci_resource_start</code> 函数或宏，以获取设备的第一个资源区域的起始地址。</p>
<h3 id="pci-iomap"><a href="#pci-iomap" class="headerlink" title="pci_iomap"></a>pci_iomap</h3><p><code>pci_iomap</code> 是一个函数，用于将 PCI 设备的 I&#x2F;O 端口或内存区域映射到内核地址空间中的一个虚拟地址。在 Linux 内核中，映射这些设备区域可以方便地对其进行读写操作。</p>
<p><code>pci_iomap</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __iomem *<span class="title function_">pci_iomap</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">int</span> bar, <span class="type">unsigned</span> <span class="type">long</span> maxlen)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受三个参数：<code>pdev</code> 是指向要映射的 PCI 设备结构体的指针，<code>bar</code> 是指定的资源区域索引，<code>maxlen</code> 是要映射的最大长度。</p>
<p>通过调用 <code>pci_iomap</code> 函数，可以将指定设备的 I&#x2F;O 端口或内存区域映射到内核地址空间中的一个虚拟地址。函数返回的虚拟地址可以用于访问设备的寄存器或内存。</p>
<p>以下是一个示例，展示了如何使用 <code>pci_iomap</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在驱动程序的初始化函数中使用 pci_iomap 进行映射</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_driver_probe</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> __iomem *io_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将设备的第一个资源区域映射到内核地址空间</span></span><br><span class="line">    io_addr = pci_iomap(pdev, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!io_addr) &#123;</span><br><span class="line">        <span class="comment">// 映射失败</span></span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用映射后的地址进行读写操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们在驱动程序的初始化函数 <code>my_driver_probe</code> 中调用了 <code>pci_iomap</code> 函数，以将设备的第一个资源区域映射到内核地址空间，并将映射后得到的虚拟地址存储在 <code>io_addr</code> 变量中。</p>
<p>需要注意的是，映射的区域在使用完毕后，应使用 <code>pci_iounmap</code> 函数解除映射。</p>
<h3 id="pci-alloc-irq-vectors"><a href="#pci-alloc-irq-vectors" class="headerlink" title="pci_alloc_irq_vectors"></a>pci_alloc_irq_vectors</h3><p><code>pci_alloc_irq_vectors</code> 是一个函数，用于在 PCI 设备上分配中断向量（IRQ vectors）。在 Linux 内核中，IRQ vectors 用于处理设备的中断请求。</p>
<p><code>pci_alloc_irq_vectors</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pci_alloc_irq_vectors</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">unsigned</span> <span class="type">int</span> min_vecs, <span class="type">unsigned</span> <span class="type">int</span> max_vecs, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受四个参数：<code>pdev</code> 是指向要分配 IRQ vectors 的 PCI 设备结构体的指针，<code>min_vecs</code> 是要分配的最小 IRQ vectors 数量，<code>max_vecs</code> 是要分配的最大 IRQ vectors 数量，<code>flags</code> 是分配标志。</p>
<p>通过调用 <code>pci_alloc_irq_vectors</code> 函数，可以为指定的 PCI 设备分配一组 IRQ vectors。这些 IRQ vectors 可以用于处理设备的中断请求。函数返回一个非负整数，表示分配的 IRQ vectors 的数量，或者返回一个负数值，表示分配失败。</p>
<p>以下是一个示例，展示了如何使用 <code>pci_alloc_irq_vectors</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在驱动程序的初始化函数中使用 pci_alloc_irq_vectors 进行 IRQ vectors 分配</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_driver_probe</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num_vecs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 1 个到 4 个 IRQ vectors</span></span><br><span class="line">    num_vecs = pci_alloc_irq_vectors(pdev, <span class="number">1</span>, <span class="number">4</span>, PCI_IRQ_MSIX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_vecs &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分配失败</span></span><br><span class="line">        <span class="keyword">return</span> num_vecs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用分配的 IRQ vectors 进行中断处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们在驱动程序的初始化函数 <code>my_driver_probe</code> 中调用了 <code>pci_alloc_irq_vectors</code> 函数，以为设备分配 1 到 4 个 IRQ vectors，并将分配的数量存储在 <code>num_vecs</code> 变量中。</p>
<p>需要注意的是，IRQ vectors 的分配和使用需要与设备的中断控制器和驱动程序的中断处理相关联。具体的中断处理逻辑和配置可能因具体的设备和驱动程序而有所不同。</p>
<h3 id="pci-read-config-dword"><a href="#pci-read-config-dword" class="headerlink" title="pci_read_config_dword"></a>pci_read_config_dword</h3><p><code>pci_read_config_dword</code> 是一个函数，用于从 PCI 设备的配置空间中读取一个 32 位的配置寄存器的值。在 Linux 内核中，PCI 设备的配置空间包含了设备的各种配置信息和寄存器。</p>
<p><code>pci_read_config_dword</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pci_read_config_dword</span><span class="params">(<span class="keyword">struct</span> pci_dev *dev, <span class="type">int</span> where, u32 *val)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受三个参数：<code>dev</code> 是指向要读取配置寄存器的 PCI 设备结构体的指针，<code>where</code> 是要读取的配置寄存器的偏移量，<code>val</code> 是用于存储读取值的指针。</p>
<p>通过调用 <code>pci_read_config_dword</code> 函数，可以从指定的 PCI 设备的配置空间中读取指定配置寄存器的值，并将读取的值存储在 <code>val</code> 指针所指向的位置。函数返回一个非负整数表示读取的字节数，或者返回一个负数值表示读取失败。</p>
<p>以下是一个示例，展示了如何使用 <code>pci_read_config_dword</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在驱动程序中使用 pci_read_config_dword 读取配置寄存器的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_driver_function</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 PCI 设备的配置空间中的配置寄存器的值</span></span><br><span class="line">    pci_read_config_dword(pdev, PCI_VENDOR_ID, &amp;value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用读取的值进行操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印读取到的值</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Value read from configuration space: 0x%x\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们在驱动程序中的某个函数 <code>my_driver_function</code> 中调用了 <code>pci_read_config_dword</code> 函数，以读取 PCI 设备的配置空间中的 <code>PCI_VENDOR_ID</code> 寄存器的值，并将读取的值存储在 <code>value</code> 变量中。</p>
<p>需要注意的是，要读取的配置寄存器的偏移量 <code>where</code> 是相对于配置空间起始位置的偏移量，而不是相对于设备的基地址。可以使用预定义的宏，如 <code>PCI_VENDOR_ID</code>、<code>PCI_DEVICE_ID</code> 等来指定要读取的寄存器。</p>
<h3 id="disable-irq-nosync"><a href="#disable-irq-nosync" class="headerlink" title="disable_irq_nosync"></a>disable_irq_nosync</h3><p><code>disable_irq_nosync()</code> 是 Linux 内核中的一个函数，用于禁用指定的中断，并确保在禁用中断之前已经完成了相关的同步操作。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">disable_irq_nosync</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;</span><br></pre></td></tr></table></figure>

<p>函数参数 <code>irq</code> 是一个表示中断号的无符号整数，用于指定要禁用的中断。</p>
<p><code>disable_irq_nosync()</code> 函数用于禁用指定的中断，并确保在禁用中断之前已经完成了同步操作。此函数不会等待挂起的中断处理程序完成，而是立即禁用中断。因此，如果有挂起的中断处理程序正在执行，它可能会被中断。</p>
<p>需要注意的是，禁用中断可能会影响系统的响应性，因此在使用 <code>disable_irq_nosync()</code> 函数时需要谨慎。通常情况下，应该在必要的时候才禁用中断，并在尽可能短的时间内重新启用中断，以减小对系统性能的影响。</p>
<h3 id="ffs"><a href="#ffs" class="headerlink" title="ffs"></a>ffs</h3><p>“ffs”函数是一个常见的C语言库函数，用于查找一个整数中从低位开始的第一个置位（即值为1）的位的位置。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ffs</span><span class="params">(<span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure>

<p>函数参数<code>value</code>是一个整数，函数返回值是从低位开始的第一个置位的位位置（从1开始计数），如果没有置位的位，则返回0。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> num = <span class="number">10</span>;  <span class="comment">// 二进制表示为 1010</span></span><br><span class="line">   <span class="type">int</span> position = ffs(num);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Position of first set bit: %d\n&quot;</span>, position);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Position of first set bit: 2</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>ffs(10)</code>的结果为2，表示整数10的二进制表示中，从低位开始的第一个置位的位位置为2。</p>
<p>“ffs”函数通常用于位操作和位掩码处理中，可以用来判断整数中是否存在置位的位，或者获取最低有效位的位置。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">Tom</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/27/pice-driver/">http://example.com/2025/03/27/pice-driver/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PCIe/">PCIe</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/27/net-driver/" title="NET Driver"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">NET Driver</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/27/u-boot-start/" title="start.s"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">start.s</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2025/03/27/PCIe/" title="PCIe"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-27</div><div class="title">PCIe</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Tom</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Tom's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#dma-alloc-noncoherent"><span class="toc-number">1.</span> <span class="toc-text">dma_alloc_noncoherent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dma-alloc-coherent"><span class="toc-number">2.</span> <span class="toc-text">dma_alloc_coherent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E4%B8%80%E8%87%B4%E6%80%A7%E5%86%85%E5%AD%98%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">非一致性内存和连续内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#build-skb-for-dma"><span class="toc-number">4.</span> <span class="toc-text">build_skb_for_dma</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kcalloc"><span class="toc-number">5.</span> <span class="toc-text">kcalloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kzalloc"><span class="toc-number">6.</span> <span class="toc-text">kzalloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kzalloc-kcalloc-%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">kzalloc kcalloc 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#devm-ioremap-resource"><span class="toc-number">8.</span> <span class="toc-text">devm_ioremap_resource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jhash"><span class="toc-number">9.</span> <span class="toc-text">Jhash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#devm-request-irq"><span class="toc-number">10.</span> <span class="toc-text">devm_request_irq</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#msecs-to-jiffies"><span class="toc-number">11.</span> <span class="toc-text">msecs_to_jiffies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dma-map-single"><span class="toc-number">12.</span> <span class="toc-text">dma_map_single</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dma-unmap-single"><span class="toc-number">13.</span> <span class="toc-text">dma_unmap_single</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mb"><span class="toc-number">14.</span> <span class="toc-text">mb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alloc-etherdev-mqs"><span class="toc-number">15.</span> <span class="toc-text">alloc_etherdev_mqs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netdev-priv"><span class="toc-number">16.</span> <span class="toc-text">netdev_priv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SET-NETDEV-DEV"><span class="toc-number">17.</span> <span class="toc-text">SET_NETDEV_DEV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-napi-add"><span class="toc-number">18.</span> <span class="toc-text">netif_napi_add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SKB-DATA-ALIGN"><span class="toc-number">19.</span> <span class="toc-text">SKB_DATA_ALIGN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-set-real-num-tx-queues"><span class="toc-number">20.</span> <span class="toc-text">netif_set_real_num_tx_queues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-set-real-num-rx-queues"><span class="toc-number">21.</span> <span class="toc-text">netif_set_real_num_rx_queues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#register-netdev"><span class="toc-number">22.</span> <span class="toc-text">register_netdev</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unregister-netdev"><span class="toc-number">23.</span> <span class="toc-text">unregister_netdev</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-napi-del"><span class="toc-number">24.</span> <span class="toc-text">netif_napi_del</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-netdev"><span class="toc-number">25.</span> <span class="toc-text">free_netdev</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spin-lock-irqsave"><span class="toc-number">26.</span> <span class="toc-text">spin_lock_irqsave</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spin-unlock-irqrestore"><span class="toc-number">27.</span> <span class="toc-text">spin_unlock_irqrestore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#napi-schedule"><span class="toc-number">28.</span> <span class="toc-text">napi_schedule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#schedule-work"><span class="toc-number">29.</span> <span class="toc-text">schedule_work</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-queue-stopped"><span class="toc-number">30.</span> <span class="toc-text">netif_queue_stopped</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-wake-queue"><span class="toc-number">31.</span> <span class="toc-text">netif_wake_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#napi-enable"><span class="toc-number">32.</span> <span class="toc-text">napi_enable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#napi-disable"><span class="toc-number">33.</span> <span class="toc-text">napi_disable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INIT-WORK"><span class="toc-number">34.</span> <span class="toc-text">INIT_WORK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-tx-start-all-queues"><span class="toc-number">35.</span> <span class="toc-text">netif_tx_start_all_queues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-carrier-on"><span class="toc-number">36.</span> <span class="toc-text">netif_carrier_on</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-tx-stop-all-queues"><span class="toc-number">37.</span> <span class="toc-text">netif_tx_stop_all_queues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-tx-stop-queue"><span class="toc-number">38.</span> <span class="toc-text">netif_tx_stop_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-carrier-off"><span class="toc-number">39.</span> <span class="toc-text">netif_carrier_off</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dma-sync-single-for-cpu"><span class="toc-number">40.</span> <span class="toc-text">dma_sync_single_for_cpu</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skb-put"><span class="toc-number">41.</span> <span class="toc-text">skb_put</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skb-record-rx-queue"><span class="toc-number">42.</span> <span class="toc-text">skb_record_rx_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skb-get-queue-mapping"><span class="toc-number">43.</span> <span class="toc-text">skb_get_queue_mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#napi-gro-receive"><span class="toc-number">44.</span> <span class="toc-text">napi_gro_receive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomic-read"><span class="toc-number">45.</span> <span class="toc-text">atomic_read</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netdev-get-tx-queue"><span class="toc-number">46.</span> <span class="toc-text">netdev_get_tx_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#READ-ONCE"><span class="toc-number">47.</span> <span class="toc-text">READ_ONCE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WRITE-ONCE"><span class="toc-number">48.</span> <span class="toc-text">WRITE_ONCE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eth-hdr"><span class="toc-number">49.</span> <span class="toc-text">eth_hdr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is-valid-ether-addr"><span class="toc-number">50.</span> <span class="toc-text">is_valid_ether_addr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is-multicast-ether-addr"><span class="toc-number">51.</span> <span class="toc-text">is_multicast_ether_addr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skb-clone"><span class="toc-number">52.</span> <span class="toc-text">skb_clone</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-running"><span class="toc-number">53.</span> <span class="toc-text">netif_running</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dev-kfree-skb-any"><span class="toc-number">54.</span> <span class="toc-text">dev_kfree_skb_any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netdev-xmit-more"><span class="toc-number">55.</span> <span class="toc-text">netdev_xmit_more</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netif-xmit-stopped"><span class="toc-number">56.</span> <span class="toc-text">netif_xmit_stopped</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pci-set-drvdata"><span class="toc-number">57.</span> <span class="toc-text">pci_set_drvdata</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pci-set-master"><span class="toc-number">58.</span> <span class="toc-text">pci_set_master</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pci-request-regions"><span class="toc-number">59.</span> <span class="toc-text">pci_request_regions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pci-resource-start"><span class="toc-number">60.</span> <span class="toc-text">pci_resource_start</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pci-iomap"><span class="toc-number">61.</span> <span class="toc-text">pci_iomap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pci-alloc-irq-vectors"><span class="toc-number">62.</span> <span class="toc-text">pci_alloc_irq_vectors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pci-read-config-dword"><span class="toc-number">63.</span> <span class="toc-text">pci_read_config_dword</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#disable-irq-nosync"><span class="toc-number">64.</span> <span class="toc-text">disable_irq_nosync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ffs"><span class="toc-number">65.</span> <span class="toc-text">ffs</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/27/net-driver/" title="NET Driver">NET Driver</a><time datetime="2025-03-27T16:21:55.088Z" title="Created 2025-03-27 16:21:55">2025-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/27/pice-driver/" title="PCIe-DRIVER">PCIe-DRIVER</a><time datetime="2025-03-27T16:21:55.088Z" title="Created 2025-03-27 16:21:55">2025-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/27/u-boot-start/" title="start.s">start.s</a><time datetime="2025-03-27T16:21:55.088Z" title="Created 2025-03-27 16:21:55">2025-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/27/wechat-little-app/note-wechat/" title="wechat">wechat</a><time datetime="2025-03-27T16:21:55.088Z" title="Created 2025-03-27 16:21:55">2025-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/27/linux/udev/udev/" title="udev">udev</a><time datetime="2025-03-27T16:21:55.088Z" title="Created 2025-03-27 16:21:55">2025-03-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Tom</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>